{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the SQANTI3 Documentation!</p> <p>Contents:</p> <ul> <li> <p>Introduction to SQANTI3</p> </li> <li> <p>Dependencies and installation</p> </li> <li> <p>Version history</p> </li> <li> <p>Isoform classification: categories and subcategories</p> </li> <li> <p>Running SQANTI3 from the wrapper</p> </li> <li> <p>Running SQANTI3 quality control</p> </li> <li> <p>Understanding the output of SQANTI3 QC</p> </li> <li> <p>IsoAnnotLite</p> </li> <li> <p>Running SQANTI3 filter</p> </li> <li> <p>Running SQANTI3 rescue</p> </li> <li> <p>Tutorial: running SQANTI3 on an example dataset</p> </li> <li> <p>Running SQANTI-reads</p> </li> <li> <p>Memory requirements to use parallelization</p> </li> </ul>"},{"location":"Dependencies-and-installation/","title":"Dependencies and installation","text":""},{"location":"Dependencies-and-installation/#table-of-contents","title":"Table of contents:","text":"<ul> <li> <p>SQANTI3 dependencies</p> </li> <li> <p>Getting ready to use SQANTI3</p> <ul> <li>Installing and updating Anaconda</li> <li>Downloading SQANTI3</li> <li>Creating the conda environment</li> <li>Installing gtfToGenePred</li> </ul> </li> <li> <p>Using SQANTI3 docker container</p> </li> </ul> <p></p>"},{"location":"Dependencies-and-installation/#dependencies","title":"Dependencies","text":"<p>Non-comprehensive list of the main dependencies for SQANTI3:</p>"},{"location":"Dependencies-and-installation/#general","title":"General","text":"<ul> <li>Perl</li> <li>Minimap2 </li> <li>Python (3.7)</li> <li>R (&gt;= 3.4.0)</li> <li>kallisto</li> <li>samtools</li> <li>STAR</li> <li>uLTRA</li> <li>deSALT</li> <li>pip</li> </ul>"},{"location":"Dependencies-and-installation/#python-related-libraries","title":"Python-related libraries","text":"<ul> <li>bx-python</li> <li>BioPython</li> <li>BCBioGFF</li> <li>cython</li> <li>NumPy</li> <li>pysam</li> <li>pybedtools</li> <li>psutil</li> <li>pandas</li> <li>scipy</li> </ul>"},{"location":"Dependencies-and-installation/#r-related-libraries","title":"R-related libraries","text":"<ul> <li>R packages for <code>sqanti3_qc.py</code> and <code>sqanti3_filter.py</code> (installed when creating the conda environment): </li> </ul>"},{"location":"Dependencies-and-installation/#external-scripts","title":"External scripts","text":"<ul> <li>We have downloaded gtfToGenePred from UCSC utilities and gave execution permissions, so it is no longer necessary to do it after downloading SQANTI3.</li> </ul>"},{"location":"Dependencies-and-installation/#getting-ready-to-use-sqanti3","title":"Getting ready to use SQANTI3","text":"<p>We recommend using Anaconda to substantially facilitate installation of all Python dependencies.  Probably you already have Anaconda installed because you use  BioConda IsoSeq(3).  Please, follow the steps here to ensure an error-free installation.  All the dependencies will be installed automatically in a conda environment.  The installation will be done just once and it usually takes less than 10 minutes to be installed. This approach has been tested successfully macOS and Linux-based operating systems. When the environment has been entirely built,  you just need to activate the conda environment of SQANTI3 and run it!</p> <p></p>"},{"location":"Dependencies-and-installation/#0-installing-and-updating-anaconda","title":"0. Installing and updating Anaconda","text":"<p>Make sure you have installed Anaconda. If so, you may add it to your PATH variable and update it -if necessary- as follows:</p> <pre><code>export PATH=$HOME/anacondaPy37/bin:$PATH\nconda -V\nconda update conda\n</code></pre> <p>If you have not installed Anaconda, the generic installer for Linux OS can be found here. Note that only Linux and Mac machines are currently supported.</p> <p></p>"},{"location":"Dependencies-and-installation/#1-downloading-sqanti3","title":"1. Downloading SQANTI3","text":"<p>Next, download the latest stable SQANTI3 release.  As of April 23rd 2025, the current version is v5.4.</p> <p>For general users, we recommend downloading the SQANTI3 repository as follows:</p> <pre><code>wget https://github.com/ConesaLab/SQANTI3/releases/download/5.4/SQANTI3_v5.4.zip\nmkdir sqanti3\nunzip SQANTI3_v5.4.zip -d sqanti3\n</code></pre> <p>If you have intentions of contributing to the development of SQANTI3, please clone the developer version.  This option will set up a git repository within your SQANTI folder and is NOT recommended for general users. Contributors outside the main development team are welcome submit a pull-request after performing the changes in their forked repositories.</p> <pre><code> git clone https://github.com/ConesaLab/SQANTI3.git\n</code></pre> <p>If you are interested in a previous version of SQANTI3, see the version history in our wiki site, which contains a detailed account of all changes introduced for versions &gt;=5.0.</p> <p></p>"},{"location":"Dependencies-and-installation/#2-creating-the-conda-environment","title":"2. Creating the conda environment","text":"<p>To use SQANTI3, you will need to move into the SQANTI3 folder that you just downloaded and create a virtual  environment including all required packages. All you need to do is run the <code>SQANTI3.conda_env.yml</code> script that  you can find in the main SQANTI folder: </p> <pre><code>conda env create -f SQANTI3.conda_env.yml\nconda activate sqanti3\n</code></pre> <p>This script contains all the information required to install the SQANTI3 dependencies.  As the environment creation progresses, you will need to type <code>y</code> when prompted to proceed with the installation.  Note that you may change the name of the environment using the <code>-n</code> argument to the <code>conda env create</code> command.  By default, the name of the environment will be SQANTI3.env.</p> <p>Once you have activated the virtual environment, you should see your prompt changing to something like this:</p> <pre><code>(sqanti3)$\n</code></pre> <p>Environment management after SQANTI3 updates</p> <p>If you had already installed SQANTI3 and have updated to a new version, creating a fresh environment may be required in major and minor releases (i.e. version bumps from 5.1.x to 5.2.x), but not in the case of patches (i.e. version bumps from 5.1.x to 5.1.y). However, if you experience errors running SQANTI3 after downloading a new version, we advise creating the conda environment again to discard dependency version issues.</p> <p></p>"},{"location":"Dependencies-and-installation/#3-installing-gtftogenepred","title":"3. Installing gtfToGenePred","text":"<p>For Linux users, the right version of gtfToGenePred is already in the <code>utilities</code> folder. However, if you are running  SQANTI3 on MacOS, you must remove the <code>src/utilities/gtfToGenePred</code> file and download the Mac version here.  </p> <p>If you are not working on a Linux system, SQANTI requires manual installation of gtfToGenePred. This tool seems to have some issues with Python 3.7 (or openssl) when installed via conda. At this point, the easiest solution is to download it from the UCSC website  and add it to the <code>SQANTI3/src/utilities</code> folder you will need to make the file executable) or to your <code>PATH</code> variable. </p> <pre><code>wget http://hgdownload.cse.ucsc.edu/admin/exe/linux.x86_64/gtfToGenePred -P &lt;path_to&gt;/SQANTI3/utilities/\nchmod +x &lt;path_to&gt;/SQANTI3/src/utilities/gtfToGenePred \n</code></pre> <p></p>"},{"location":"Dependencies-and-installation/#using-sqanti3-docker-container","title":"Using SQANTI3 docker container","text":"<p>A docker container is available from version 5.2.2 onwards in dockerhub</p> <p>docker pull anaconesalab/sqanti3</p> <p>On the other hand, the dockerfile is available in the master branch of the git repository which you can use to create a Docker image of SQANTI3, not yet publicly available. The steps needed to use it are:</p> <ul> <li>Build the image</li> </ul> <p>In the same folder as your dockerfile (preferably, but not necessarily, with only the dockerfile), run</p> <pre><code>docker build -t SQANTI3 -f Dockerfile .\n</code></pre> <ul> <li>Execute the container: all three modules of SQANTI3 are hosted inside the container and can be executed:</li> </ul> <pre><code>docker run -it SQANTI3 sqanti3_qc.py -h \ndocker run -it SQANTI3 sqanti3_filter.py -h \ndocker run -it SQANTI3 sqanti3_rescue.py -h \n</code></pre> <p>In order to make docker be aware of your files, input files and output folder must be bound to a path in your filesystem, as otherwise, docker won't be able to read them. The path /data2 inside the container is free to be mapped to your project folder, and it's the default working directory inside the container.</p> <pre><code>docker run -it -v &lt;my-project-path&gt;:/data2 SQANTI3 sqanti3_qc.py &lt;sqanti_qc_args&gt;\n</code></pre>"},{"location":"Dependencies-and-installation/#docker-minifaq","title":"Docker miniFAQ","text":"<ul> <li>I'm having trouble to build the docker image on my Mac</li> </ul> <p>Building the image on Mac systems may require adding the \"--platform linux/amd64\" parameter when building the image.</p> <ul> <li>Can I use a singularity image instead of docker? </li> </ul> <p>Once the docker image is built, you can turn it into a singularity image either from dockerhub or from the installed local version:</p> <pre><code>singularity build sqanti3.sif docker://anaconesalab/sqanti3\nsingularity build sqanti3.sif docker-daemon://sqanti3\n</code></pre> <p>However you build the singularity image, you can use \"singularity run sqanti3.sif \" exactly as you would with the docker container. Note that using \"singularity exec\" will not load the conda environment by default <ul> <li>How can I make Docker generated output to be owned by my user and not root?</li> </ul> <p>This is the default behaviour of docker. The most straightforward way to solve it is by telling docker to execute the container with a specific user with -u parameter</p> <pre><code>docker run -it -u $(id -u):$(id -g) sqanti3 &lt;sqanti3_qc.py/sqanti3_filter.py/sqanti3_rescue.py&gt; \n</code></pre> <p>This command will execute the container with your current user, and thus, the resulting files will be owned by your user and group</p>"},{"location":"Home/","title":"Home","text":"<p>Welcome to the SQANTI3 wiki!</p> <p>Wiki contents:</p> <ul> <li> <p>Introduction to SQANTI3</p> </li> <li> <p>Dependencies and installation</p> </li> <li> <p>Version history</p> </li> <li> <p>Isoform classification: categories and subcategories</p> </li> <li> <p>Running SQANTI3 from the wrapper</p> </li> <li> <p>Running SQANTI3 quality control</p> </li> <li> <p>Understanding the output of SQANTI3 QC</p> </li> <li> <p>IsoAnnotLite</p> </li> <li> <p>Running SQANTI3 filter</p> </li> <li> <p>Running SQANTI3 rescue</p> </li> <li> <p>Tutorial: running SQANTI3 on an example dataset</p> </li> <li> <p>Running SQANTI-reads</p> </li> <li> <p>Memory requirements to use parallelization</p> </li> </ul>"},{"location":"Introduction-to-SQANTI3/","title":"Introduction to SQANTI3","text":""},{"location":"Introduction-to-SQANTI3/#table-of-contents","title":"Table of contents:","text":"<ul> <li> <p>Introduction</p> <ul> <li>SQANTI3 and the Functional IsoTranscriptomics (FIT) pipeline</li> <li>Before running SQANTI3: recommended long read processing workflow</li> </ul> </li> <li> <p>How does SQANTI3 work?</p> </li> <li> <p>SQANTI3 structure</p> <ul> <li>Source folder <li>Utilities folder</li> <li>Data folder</li> <li>Example folder</li> <p></p>"},{"location":"Introduction-to-SQANTI3/#introduction","title":"Introduction","text":"<p>SQANTI3 is the newest version of the SQANTI tool.  SQANTI3 combines features from the original SQANTI and from SQANTI2, as well as newly implemented functionalities and  transcript features.</p> <p>Disclaimer: please note that, although still available, both SQANTI and SQANTI2 are deprecated and will no longer be  maintained/updated. All development efforts will continue in SQANTI3, aiming to providing the most comprehensive characterization of long read-defined transcriptomes for the community.</p> <p></p>"},{"location":"Introduction-to-SQANTI3/#sqanti3-and-the-functional-isotranscriptomics-fit-pipeline","title":"SQANTI3 and the Functional IsoTranscriptomics (FIT) pipeline","text":"<p>SQANTI3 constitutes the first module of the Functional IsoTranscriptomics (FIT)  pipeline, which is an end-to-end strategy to perform isoform-level bioinformatics analyses.  The SQANTI3 tool is designed to enable quality control and filtering of long read-defined transcriptomes, which are often rich in artifacts and false-positive isoforms. Therefore, a good curation of the transcriptome is indispensable to proceed with FIT analysis and produce valid, biologically sound conclusions/hypothesis. </p> <p>After generating a high-quality transcriptome with SQANTI3, downstream steps include:</p> <ul> <li>Functional annotation of isoform models, including positionally-defined functional features such as motifs, domains, etc. IsoAnnot, a tool for de novo annotation of isoforms, is currently under development, however, users can run IsoAnnotLite within or outside of SQANTI3 to impute functional features from other already-annotated transcriptomes.</li> <li>Expression-based functional analysis using tappAS. tappAS is a Java GUI application  that leverages both expression and domain/motif annotation information to gain insight into the functional implications  of alternative isoform expression.</li> </ul> <p></p>"},{"location":"Introduction-to-SQANTI3/#before-running-sqanti3-recommended-long-read-processing-workflow","title":"Before running SQANTI3: recommended long read processing workflow","text":"<p>Here is our recommended workflow, including the best way to generate the SQANTI3 inputs and how to proceed after QC and filtering:</p> <ol> <li>Sample pooling: while we are aware that some users may have long read data from several replicates and/or samples, we recommend pooling all long read samples to build a single transcriptome per experiment.</li> <li>Long read data processing using your preferred transcriptome-building tool. We do not recommend using SQANTI3 on  raw long reads, as it is NOT designed as a tool for long read data QC.</li> <li>Collapse of isoform models. Typically, long read data processing pipelines generate a large number of highly redundant isoform models. We recommend collapsing these using tools such as cDNA_Cupcake or  TAMACollapse to reduce the number of isoforms and create unique isoform models prior to running SQANTI3.</li> <li>Quality control and filtering: we strongly encourage users to do as careful an inspection of their long read-defined transcriptomes as possible, including filtering their transcriptome to remove potential false positive isoforms, which are abundant in long read-generated transcriptomes.</li> <li>Quantification of the filtered transcriptome using short/long reads and your preferred tool. We do not recommend using the expression estimates input into SQANTI3 for downstream analysis: these are used for quality control purposes only. Once all artifacts are removed from the transcriptome, the reads can be used to obtain a more accurate quantification.</li> </ol> <p></p>"},{"location":"Introduction-to-SQANTI3/#how-does-sqanti3-work","title":"How does SQANTI3 work?","text":"<p>SQANTI3 is a tool for in-depth characterization of isoforms obtained by full-length transcript sequencing,  which are commonly returned in a fasta or GTF file format. SQANTI3 combines the long read-defined transcripts with the reference annotation as well as with other orthogonal data to provide a wide range of descriptors of transcript quality. SQ3 generates a comprehensive report to facilitate quality control and filtering of the isoform models.</p> <p>SQANTI3 is mainly designed to perform two  different tasks, both of them equally important:</p> <ol> <li>Isoform classification and quality control (SQANTI3 QC) for long read-defined transcriptomes. The SQ3 categories and subcategories,  together with a long list of transcript-level attributes and descriptors, allow users to carefully inspect the properties of their isoform models, as well as identify potential problems generated during library preparation and raw data processing.</li> <li>Artifact filtering (SQANTI3 filter) for long read-defined transcriptomes. Using the large number of descriptors calculated by SQANTI3, users can make informed decisions to remove potential false positive isoforms from their transcriptomes. This is particularly relevant considering the biases and pitfalls of current long read sequencing protocols.</li> </ol> <p>To gain insight into these two steps, we encourage reading the original SQANTI publication. Recently, however, we have implemented a final step in the SQANTI3 workflow:</p> <ol> <li>Reference transcript rescue (SQANTI3 rescue) to find matching reference transcript for discarded artifacts. This module intends to keep the diversity in the transcriptome, i.e. preventing loss of transcripts with (mostly) valid junction chains for which a long-read defined isoform could not be validated or even the removal of genes for which all isoforms were catalogued as artifacts by the filter, in spite of having long read-based evidence of expression. By running the rescue, SQANTI3 will select a set of reference transcripts that the discarded artifacts can be confidently assigned to, and add them to expand the filtered transcriptome.</li> </ol> <p></p> <p></p>"},{"location":"Introduction-to-SQANTI3/#sqanti3-structure","title":"SQANTI3 structure","text":"<p>At the moment, the SQANTI3 tool is directly called using the wrapper <code>sqanti3</code>. This main wrapper orchestrates the execution of the three primary modules. Each module is designed to perform a specific function within the SQANTI3 workflow, implemented as separate Python scripts:</p> <ul> <li><code>sqanti3_qc.py</code> for quality control.</li> <li><code>sqanti3_filter.py</code> for transcriptome filtering/curation.</li> <li><code>sqanti3_rescue.py</code> to replace artifacts by their closest matching reference transcript.</li> </ul> <p>To maintain a clean and organized codebase, the detailed implementation for each core module and the auxiliary tools used in the workflow are housed within the <code>src</code> (source) directory. As of the latest release, only sqanti3_qc.py has been fully modularized.</p> <p></p>"},{"location":"Introduction-to-SQANTI3/#source-folder","title":"Source folder","text":"<p>The <code>src</code> directory contains all the minor modules that each one of the sqanti blocks and the parser use to function properly. Each script has functions or classes according to their function within SQANTI3: classification, utilities, parsers, QC classes, etc.</p> <p></p>"},{"location":"Introduction-to-SQANTI3/#utilities-folder","title":"Utilities folder","text":"<p>The <code>utilities</code> folder contains all the auxiliary scripts and functions required to run <code>sqanti3_qc.py</code> and <code>sqanti3_filter.py</code>. Under the main directory, you will find:</p> <ul> <li><code>IsoAnnotLite_SQ3.py</code>: IsoAnnotLite script. Used to generate functional annotations and tappAS-compatible outputs.</li> <li>gtfToGenePred: UCSC conversion tool, obtained (see details here). Used during QC.</li> <li><code>indels_annot.py</code>: when a fasta file is provided as input, corrects indels in transcripts (note that SQANTI3 QC requires a GTF by default, so this function is rarely used).</li> <li><code>rt_switching.py</code>: function to check splice junctions for potential RT switching.</li> <li><code>short_reads.py</code>: used to process raw short-read data when supplied to <code>sqanti3_qc.py</code>.</li> </ul>"},{"location":"Introduction-to-SQANTI3/#filter","title":"Filter","text":"<p>The <code>filter</code> subfolder contains two R scripts, each for one of the filters available in SQANTI3 (i.e. rules and machine learning-based).  In addition, a JSON file containing the default set of rules for the rules filter (which are equivalent to running the old RulesFilter in SQANTI2 and SQANTI3 for versions &lt; 5.0).</p>"},{"location":"Introduction-to-SQANTI3/#rescue","title":"Rescue","text":"<p>The <code>rescue</code> subfolder contains a series of R scripts implementing the different rescue steps. These are run internally by the rescue wrapper (<code>sqanti3_rescue.py</code>) to perform the rescue.</p>"},{"location":"Introduction-to-SQANTI3/#reports","title":"Reports","text":"<ul> <li>The <code>report_qc</code> folder contains the main R script and auxiliary plotting functions/scripts used to generate the SQANTI3 QC report.</li> <li>The <code>report_filter</code> folder contains the main R script and auxiliary plotting functions used to generate the SQANTI3 filter report.</li> </ul>"},{"location":"Introduction-to-SQANTI3/#gmst","title":"GMST","text":"<p>GeneMarkST tool. Used internally during QC for ORF prediction.</p> <p></p>"},{"location":"Introduction-to-SQANTI3/#data-folder","title":"Data folder","text":"<p>The <code>data</code> folder contains pre-computed TSS/TTS orthogonal data that is ready to be used to run SQANTI3 QC (see additional inputs section), avoiding the need for users to download them from reference databases.</p> <ul> <li><code>ref_TSS_annotation</code> subfolder: human and mouse CAGE data from the refTSS database.</li> <li><code>polyA_motif</code> subfolder: contains a list of human and mouse canonical polyadenylation motifs. </li> </ul> <p></p>"},{"location":"Introduction-to-SQANTI3/#example-folder","title":"Example folder","text":"<p>This folder contains all the necessary inputs to run SQANTI3 on an example dataset. This data was obtained from public PacBio data, in particular, it consists in a set of transcripts generated using long reads from the Universal Human Reference RNA (UHR) (see dataset details here). For convenience, we have only selected those in chromosome 22.  This small dataset can be used to test SQANTI3 and/or to follow the  SQANTI3 example tutorial in the Wiki. </p> <p>In addition, we provide the outputs generated after running QC and filters (both machine learning and rules) on the example dataset under the corresponding <code>*_output</code> subfolders.</p>"},{"location":"Introduction-to-SQANTI3/#test-folder","title":"Test folder","text":"<p>Newly implemented, and in development, test suite for SQANTI3. This test suite is being developed as SQANTI3 is being modularized, with the aim to keep SQANTI3 as stable as possible in future releases. If you find any issue with the test suite, add it as an issue and it will be updated as soon as possible.</p>"},{"location":"IsoAnnotLite/","title":"IsoAnnotLite","text":""},{"location":"IsoAnnotLite/#table-of-contents","title":"Table of contents:","text":"<ul> <li> <p>Summary</p> </li> <li> <p>Arguments and parameters in IsoAnnotLite</p> </li> <li> <p>IsoAnnotLite integration within SQANTI3 QC</p> </li> <li> <p>Appendix I: how does IsoAnnotLite work?</p> </li> <li> <p>Appendix II: IsoAnnotLite statistics</p> </li> <li> <p>Appendix III: tappAS GFF3 file format</p> </li> </ul> <p></p>"},{"location":"IsoAnnotLite/#summary","title":"Summary","text":"<p>IsoAnnotLite is a python script that allows you to transfer isoform-level functional feature annotations from an existing tappAS-like GFF3 file to the SQANTI3 output (i.e. a set of long read-defined transcripts). The resulting file has the proper structure to be loaded into tappAS for isoform-level functional analysis. If the reference GFF3 annotation file is not provided, only structural information will be included in the IsoAnnotLite-generated GFF3 file. The transference is done at the genomic positon level for transcript and protein annotations, while all gene-level annotations (e.g. Gene Ontology terms) are automatically transferred by gene ID.</p> <p></p> <p></p>"},{"location":"IsoAnnotLite/#arguments-and-parameters-in-isoannotlite","title":"Arguments and parameters in IsoAnnotLite","text":""},{"location":"IsoAnnotLite/#input-files","title":"Input files:","text":"<p>Mandatory: the basic input required to run IsoAnnotLite are three of the output files generated by SQANTI3 QC: - GTF file: output as <code>*_corrected.gtf</code>. In order for IsoAnnot Lite to work propperly, the reference annotation used in SQANTI3 has to contain the same gene names as the ones in the functional annotation. Contains the long read-defined transcript sequences in GTF format. - Classification file: output as <code>*_classification.txt</code>. Tab-delimited file containing one entry per transcript and a large number of columns containing SQANTI3 attributes. - Junction file: output as <code>*_junctions.txt</code>. Tab-delimited file containing junction-level information for all the transcripts included in the classification file.</p> <p>Optional: the <code>-gff3</code> argument can be used tu supply an already-annotated GFF3 file containing transcript-level functional features. When this argument is not used, a tappAS-compatible GFF3 will still generated for the user to load into tappAS, however, it will only contain structural information (transcript length, exons, UTR, etc.). Pre-computed tappAS annotation files for human, mouse, Drosophila, Arabidopsis and maize are available here.</p>"},{"location":"IsoAnnotLite/#parameters","title":"Parameters:","text":"<p>All of the following parameters are optional:</p> <ul> <li><code>-o</code>: name for the resulting GFF3 file.</li> <li><code>-stdout</code>: name for the statistics results file. Only when GFF3 it is used. If not used, no file will be generated.</li> <li><code>novel</code>: if it is used, all the transcripts will be treated as novel trasncripts, meaning that each transcript will be annotated using functional information from all the transcripts that belong to the same gene in the reference GFF3, instead of transferring annotations from transcripts with matching IDs (default).</li> <li><code>nointronic</code>: if provided, intronic features will not be annotated (e.g. RBPs).</li> <li><code>statistics</code>: deprecated (now IsoAnnotLite always shows the statistic results).</li> <li><code>saveTranscriptIDs</code>: when supplied to IsoAnnotLite, five additional output files will be created to report the IDs of the transcripts that generated problems during the feature transfer process:</li> <li>Transcripts with a reference <code>associated_transcript</code> not annotated by positional transference: <code>file_trans_not_annot_by_PF.txt</code>.</li> <li>Novel transcripts not annotated by positional transference: <code>file_novel_not_annot_by_by_PF.txt</code>.</li> <li>SQ3 reference gene was not found in the GFF3 annotation <code>file_reference_gene_not_annot.txt</code>.</li> <li>Transcripts not annotated because no features in the GFF3 annotation could be matched by position: <code>file_reference_transcript_not_annot.txt</code>.</li> <li>SQ reference gene (<code>associated_gene</code>) field was empty: <code>file_transcript_wo_gene_ID.txt</code>.</li> </ul> <p></p>"},{"location":"IsoAnnotLite/#isoannotlite-integration-within-sqanti3-qc","title":"IsoAnnotLite integration within SQANTI3 QC","text":"<p>As described in the SQANTI3 QC documentation, IsoAnnotLite is run internally by SQANTI3 QC if the <code>--isoAnnotLite</code> flag is supplied. In addition, users may add a tappAS reference GFF3 file via the <code>--gff3</code> argument to perform functional feature transfer. Within SQANTI3, IsoAnnotLite is run with the following parameters by default:</p> <pre><code>python path_to_utilities/IsoAnnotLite_SQ3.py \n             \\  *_corrected.gtf *_classification.txt *_junctions.txt \n             \\  -gff3 *.gff3 \n             \\  -o out_prefix -novel -stdout out_dir\n</code></pre> <p>Note that this behavior cannot be modified when running SQANTI3: instead, if you wish for IsoAnnotLite to behave differently (i.e. supply flags other than -novel, which is activated by default in the SQANTI3 QC run), you will need to run in independently after obtaining the output of SQANTI3 QC.</p> <p>The <code>IsoAnnotLite_SQ3.py</code> script included in SQ3's <code>utilities</code> folder is consistently updated as new versions of IsoAnnotLite are released. If you are running IsoAnnotLite independently, please make sure you use the latest version. To download the current version of IsoAnnotLite (v2.7.3), click here.</p> <p></p>"},{"location":"IsoAnnotLite/#appendix-how-does-isoannotlite-work","title":"Appendix: how does IsoAnnotLite work?","text":""},{"location":"IsoAnnotLite/#1-reading-reference-annotation-file-and-creating-data-variables","title":"1. Reading reference annotation file and creating data variables","text":"<p>If used, the reference annotation file (GFF3) is read. The function creates different Python dictionaries to save all the relevant transcript-level information.</p>"},{"location":"IsoAnnotLite/#2-reading-sqanti3-files-and-creating-an-auxiliar-gff3","title":"2. Reading SQANTI3 files and creating an auxiliar GFF3","text":"<p>IsoAnnotLite next reads the three input files generated by SQ3 and creates an auxiliar GFF3 (to prevent memory overload). This auxiliar GFF3 will later be used to create the final GFF3 file.</p>"},{"location":"IsoAnnotLite/#3-transforming-cds-local-positions-to-genomic-position","title":"3. Transforming CDS local positions to genomic position","text":"<p>Using the SQ3 input files and GFF3 information, IsoAnnotLite transforms all CDS local positions to genome positions using exon information.</p>"},{"location":"IsoAnnotLite/#4-transforming-feature-local-positions-to-genomic-position","title":"4. Transforming feature local positions to genomic position","text":"<p>Using the reference GFF3 file, transcript-level functional feature positions are transformed to genomic position by the same methodology.</p>"},{"location":"IsoAnnotLite/#5-generating-transcript-level-information-per-gene","title":"5. Generating transcript-level information per gene","text":"<p>Create a dictionary where gene, feature and genomic positions are stored.</p>"},{"location":"IsoAnnotLite/#6-mapping-transcript-features-between-gff3s","title":"6. Mapping transcript features between GFF3s","text":"<p>Features are transferred by matching genomic positions: features that are positionally defined within a long read-defined transcript in the SQ3 output will be annotated as belonging to that transcript.</p> <p>In the process of transferring features between the GFF3 and the SQ3 transcripts, IsoAnnotLite behaves differently depending on the type of feature that is being handled: - Transfer a feature located in the 3/5 UTR region. - Transfer a feature located in the CDS. - Transfer protein features. - Transfer gene-level characteristics.</p> <p>In addition, two different feature transfer methodologies are implemented depending on whether the SQ3 transcript has a match in the GFF3 file (this will be the case for FSM and ISM transcripts) or needs to be treated as a novel transcript (i.e. NIC and NNC). - In case a matching reference transcript is found (and the <code>-novel</code> flag is not used), only the matching reference transcript will be used to transfer features at all the levels mentioned above.  - For novel transcripts (or for all transcripts if the <code>-novel</code> flag is used), IsoAnnotLite will iterate all the same-gene transcripts found in the GFF3 (using the <code>associated_gene</code> column in the SQANTI3 classification file) to retrieve positionally-defined features. The procedure will be the same, but it is running as many times as the number of transcripts the gene has.</p> <p>To transfer UTR features, its genomic feature position must be inside the transcript exons but outside CDS region.</p> <p>For CDS transcript features, two requirements must be met: 1) the feature must be contained within the transcript's exons as well as inside the CDS region; and 2) if a feature has start and end positions situated in different exons, the end and the start of the exons for both transcripts must be the same in order for IsoAnnotLite to transfer the feature.</p> <p>Furthermore, for protein features, we check both transcripts are coding and have similar CDS. If all CDS exons are the same for both transcripts, all protein features are transferred. In the other case, at least one CDS exon should be a partial match. At least one CDS genomic region overlaps between both transcripts. In that case, IsoAnnotLite checks if any protein feature can be transferred by genomic position.</p> <p>For gene-level characteristics (such as GOTerms), we decided to always transfer the information across matching gene IDs. Novel transcript procedure is equivalent, but annotations can come from multiple transcripts. Duplicated annotations are then removed.</p>"},{"location":"IsoAnnotLite/#7-adding-extra-information-to-the-gff3-columns","title":"7. Adding extra information to the GFF3 columns","text":"<p>During this step, a feature type flag is added to the GFF3 columns. This flag is required in some of tappAS' analysis and indicates if the annotation is defined at the transcript, protein or gene level.</p> <p>Currently, this method is a hand-written methodology and cannot automatically detect feature type -this means that we have pre-defined the feature type for a long list of functional feature categories that we generally work with in the tappAS framework. Therefore, if you are working with a different kind of functional feature, IsoAnnotLite will display a warning. In this case, we recommend manually editing the <code>updateGTF()</code> function inside IsoAnnotLite to add your new feature, following the same structure as in the code. </p> <p>The feature types supported by tappAS are:  - T for transcript-level features. - P for protein-level features. - N for gene-level features.</p>"},{"location":"IsoAnnotLite/#8-reading-and-sorting-the-gff3-file","title":"8. Reading and sorting the GFF3 file","text":"<p>Sorting the GFF3 by transcript ID, that is, all entries corresponding to the same transcripts need to be together in the same chunk of the GFF3.</p>"},{"location":"IsoAnnotLite/#9-updating-gene-descriptions","title":"9. Updating gene descriptions","text":"<p>If missing from the SQANTI3 GTF, gene descriptions are updated using the information in the reference GFF3 file. After this step, the final GFF3 is ready.</p> <p></p>"},{"location":"IsoAnnotLite/#appendix-ii-isoannotlite-statistics","title":"Appendix II: IsoAnnotLite statistics","text":"<p>Statistics are divided into three main sections:</p> <ol> <li>Transcript-level summary. This section will display several entries with the number of transcripts that have been successfully annotated or not, and the reason. The information is shown independently for FSM/ISM and novel transcripts. Users will also see: </li> <li>No. of total transcripts that have been annotated by genomic positional feature transference. </li> <li>No. of transcripts not annotated because the reference transcript has no annotations to transfer. </li> <li>No. of transcripts that were not annotated because no features matched by positional transference. </li> <li> <p>No. of transcripts that were not annotated because the gene that they are assigned to by the <code>associated_gene</code> SQ3 column was not found in the reference GFF3. </p> </li> <li> <p>Feature transfer summary. For each of the functional feature categories included in the reference GFF3, this section will show how many transcripts have been annotated with at least one feature from that category.</p> </li> <li> <p>Feature-level summary. This section contains the same information as in (2), but in this case, the information is displayed by number of features instead of my number of transcripts. This summarizes how may features have been transferred from the reference GFF3 into the new GFF3 annotation file.</p> </li> </ol> <p>At the end of the statistics file, a summary line is shown including the percentage (%) of features have been transferred in total. However, keep in mind that this count is only exact when no novel transcripts are annotated: otherwise, since a novel transcript can receive annotations from multiple reference transcripts (all of which are counted, even if they are collapsed afterwards to remove redundancies), annotated features can be counted several times. Therefore, the result will correspond to the total number of features that have been annotated against the total number of feature transfer \"events\" that have been tried by IsoAnnotLite.</p> <p></p>"},{"location":"IsoAnnotLite/#appendix-iii-tappas-gff3-file-format","title":"Appendix III: tappAS GFF3 file format","text":"<p>The tappAS functional annotation GFF3 file follows the basic Generic Feature Format 3 (GFF3). However, it has been slightly modified to suit the application: the \u201cscore\u201d and \u201cphase\u201d columns are not used and some of the attributes may not fully abide by the formal specifications. The file consists of a set of annotation features for each transcript. </p> <p>The file is divided into blocks, each corresponding to a transcript. Within each block, the set of features is divided into sections as follows:</p> <ul> <li>Transcript 1</li> <li>Transcript Level Feature Annotations \u2013 basic transcript information, UTR motifs, microRNAs, etc.</li> <li>Genomic Level Feature Annotations \u2013 exons, splice junctions, etc.</li> <li>Protein Level Feature Annotations \u2013 gene ontology features, domains, phosphorylation sites, etc.</li> <li>Transcript 2</li> <li>...</li> <li>Transcript 3</li> <li>\u2026</li> </ul> <p>The annotation features must be named as expected by tappAS:</p> Source Feature Description tappAS transcript Start of transcript features tappAS gene Gene information tappAS CDS CDS information tappAS genomic Start of genomic features tappAS exon Exon tappAS splice_junction Splice junction tappAS protein Start of protein features <p>In addition, the remaining attributes must be named as follows:</p> Attribute Description ID Feature ID Name Feature name Desc Feature description Chr Feature chromosome <p>For reference, here is a snippet of a tappAS-formatted GFF3 file (header should NOT be included):</p> SeqName Source Feature Start End Score Strand Phase Attributes PB.3189.4 tappAS transcript 1 1399 . + . ID=XM_006524897.1; primary_class=full_splice_match; PosType=T PB.3189.4 tappAS gene 1 1399 . + . ID=Qpct; Name=Qpct; Desc=glutaminyl-peptide cyclotransferase (glutaminyl cyclase); PosType=T PB.3189.4 tappAS CDS 10 951 . + . ID=XP_006524960.1; PosType=T PB.3189.4 UTRsite 3\u2019UTRmotif 1288 1295 . + . ID=U0023; Name=K-BOX; Desc=K-Box; PosType=T PB.3189.4 UTRsite PAS 1380 1399 . + . ID=U0043; Name=PAS; Desc=Polyadenylation Signal; PosType=T PB.3189.4 mirWalk miRNA 986 993 . + . ID=mmu-miR-495-5p; Name=mmu-miR-495-5p; Desc=UTR3; PosType=T PB.3189.4 tappAS genomic 1 1 . + . Chr=chr17; PosType=G PB.3189.4 tappAS exon 79052257 79052388 . + . Chr=chr17; PosType=G PB.3189.4 tappAS exon 79070673 79070951 . + . Chr=chr17; PosType=G PB.3189.4 tappAS exon 79077482 79077658 . + . Chr=chr17; PosType=G PB.3189.4 tappAS exon 79079467 79079566 . + . Chr=chr17; PosType=G PB.3189.4 tappAS exon 79081747 79081863 . + . Chr=chr17; PosType=G PB.3189.4 tappAS exon 79089623 79090216 . + . Chr=chr17; PosType=G PB.3189.4 tappAS splice_junction 79052388 79070673 . + . ID=known_canonical; Chr=chr17; PosType=G PB.3189.4 tappAS splice_junction 79070951 79077482 . + . ID=known_canonical; Chr=chr17; PosType=G PB.3189.4 tappAS splice_junction 79077658 79079467 . + . ID=known_canonical; Chr=chr1; PosType=G \u2026 \u2026 \u2026 \u2026 \u2026 \u2026 \u2026 \u2026 \u2026 PB.3189.4 tappAS protein 1 313 . + . ID=NP_001303658.1; PosType=P <p>Note that generating an annotation file is not a trivial task and it\u2019s not recommended unless you have a good programming background and knowledge of annotation features. IsoAnnotLite has been specifically developed to assist with the file formatting and functional feature transference task.</p>"},{"location":"Running-SQANTI-BUGSI/","title":"Running SQANTI BUGSI","text":""},{"location":"Running-SQANTI-BUGSI/#invocation-within-sqanti3","title":"Invocation within SQANTI3","text":"<ul> <li>You pass <code>--bugsi human</code> (or <code>mouse</code>) on the SQANTI3 command line.</li> <li>In <code>src/qc_pipeline.py</code>, SQANTI3 sees <code>args.bugsi</code> and calls:   <code>python   generate_bugsi_report(bugsi, outputClassPath, args.isoforms)</code></li> </ul>"},{"location":"Running-SQANTI-BUGSI/#driving-script-inputs","title":"Driving script &amp; inputs","text":"<ul> <li><code>generate_bugsi_report()</code> (in <code>src/qc_output.py</code>) builds and executes:   <code>bash   Rscript /\u2026/utilities/report_qc/BUGSI_report.R \\     &lt;classification.txt&gt; \\     &lt;bugsi_&lt;human|mouse&gt;.gtf&gt; \\     &lt;your_transcript.gtf&gt; \\     &lt;utilities_path&gt;</code></li> <li>Inputs:</li> <li><code>classification.txt</code>: SQANTI3 classification of each isoform</li> <li><code>bugsi_&lt;species&gt;.gtf</code>: gold-standard GTF of known BUGSI genes (with <code>ensembl</code>/<code>refseq</code>/<code>gene_name</code> fields)</li> <li><code>transcript.gtf</code>: your full transcript GTF</li> <li>path to the utilities directory</li> </ul>"},{"location":"Running-SQANTI-BUGSI/#core-r-pipeline-bugsi_reportr","title":"Core R pipeline (<code>BUGSI_report.R</code>)","text":"<ol> <li>Load libraries: ggplot2, dplyr, rtracklayer, Gviz, rmarkdown, etc.</li> <li>Import data </li> <li><code>classification_data</code> \u2190 read SQANTI3 TSV  </li> <li><code>bugsi_gtf</code> \u2190 <code>rtracklayer::import()</code> \u2192 extract gene\u2010level table  </li> <li><code>transcript_gtf</code> \u2190 <code>rtracklayer::import()</code></li> <li>ID-type classification </li> <li>Classify each <code>associated_gene</code> as \"ensembl\", \"refseq\", \"gene_name\", or \"unknown\" via regex  </li> <li>Choose dominant ID; if Ensembl, strip version suffixes from <code>gene_id</code> in transcripts</li> <li>Clean &amp; explode fusion records </li> <li>Drop fusion records, then re-add them with split <code>associated_gene</code> lists  </li> <li>Strip transcript/gene version suffixes and dedupe</li> <li>Define benchmarking sets </li> <li>BUGSI_transcripts: isoforms whose <code>associated_gene</code> is in the gold list  </li> <li>TP (True Positives): subset of BUGSI_transcripts with <code>subcategory == \"reference_match\"</code> </li> <li>PTP (Partial TP): FSM/ISM but not RM  </li> <li>FP (False Positives): novel categories (NIC, NNC, genic, fusion)  </li> <li>FN (False Negatives): gold\u2010standard genes with no FSM/ISM hit</li> <li>Compute metrics </li> <li>Sensitivity = # unique TP genes / # gold\u2010standard genes  </li> <li>Non-redundant Precision = TP / total BUGSI_transcripts  </li> <li>Redundant Precision = (TP + PTP) / total BUGSI_transcripts  </li> <li>Positive Detection Rate = # unique (TP+PTP) genes / # gold\u2010standard genes  </li> <li>False Discovery Rate = (total BUGSI_transcripts \u2013 TP) / total BUGSI_transcripts  </li> <li>False Detection Rate = FP / total BUGSI_transcripts  </li> <li>Redundancy = (FSM + ISM) / # unique (TP+PTP) genes</li> <li>Render report </li> <li>Tabulate and round percentages  </li> <li>Assign each isoform to \"TP\", \"PTP\", \"FP\", or \"Missing\" (for FN)  </li> <li>Call <code>rmarkdown::render()</code> on <code>SQANTI3_BUGSI_Report.Rmd</code></li> </ol>"},{"location":"Running-SQANTI-BUGSI/#htmlcssjs","title":"HTML/CSS/JS","text":"<ul> <li><code>bugsi_style.css</code> and <code>bugsi_script.js</code> accompany the Rmd to style the interactive report.</li> </ul>"},{"location":"Running-SQANTI-BUGSI/#output","title":"Output","text":"<ul> <li><code>&lt;your_prefix&gt;_BUGSI_report.html</code> in your output directory, containing summary tables, bar/pie charts of TP/PTP/FP/FN, and interactive drill\u2011downs.</li> </ul> <p>In short: BUGSI cross\u2011links your SQANTI3 classification against a curated GTF of known single\u2011isoform genes, segments isoforms into TP/PTP/FP/FN, computes standard metrics, and wraps everything in a self\u2011contained RMarkdown HTML report.</p> <p></p>"},{"location":"Running-SQANTI-BUGSI/#bugsi-gene-selection-pipeline","title":"BUGSI Gene Selection Pipeline","text":""},{"location":"Running-SQANTI-BUGSI/#1-annotation-curation","title":"1. Annotation Curation","text":"<ul> <li>Retrieved GTFs from MANE Select (Human), GENCODE (Human/Mouse), and NCBI RefSeq (Human/Mouse).  </li> <li>Cross-validation: kept only genes with a single, perfectly matching isoform across all sources (splice junctions, TSS, TTS).  </li> <li>Initial candidates: 1,925 human genes; 2,345 mouse genes.</li> </ul>"},{"location":"Running-SQANTI-BUGSI/#2-expression-filtering","title":"2. Expression Filtering","text":"<ul> <li>Quantified median expression using GTEx (Human) and ENCODE (Mouse) RNA\u2011seq.  </li> <li>Tissue-specific sets: \u2265 5 TPM in at least one tissue.  </li> <li>Universal set: \u2265 1 TPM across every evaluated tissue.  </li> <li>Integrated housekeeping genes from HRT Atlas v1.0.</li> </ul>"},{"location":"Running-SQANTI-BUGSI/#3-alternative-splicing-exclusion","title":"3. Alternative Splicing Exclusion","text":"<ul> <li>Multi-exon genes:  </li> <li>Extracted annotated junction coverages from Recount3.  </li> <li>Computed \u03bc = (\u03a3 C\u1d62) / n.  </li> <li>Threshold T = \u03b1 \u00d7 \u03bc (\u03b1 = 0.01).  </li> <li>Excluded any gene with novel junction coverage C\u2099\u2092\u1d65\u2091\u2097 &gt; T.  </li> <li>Used IntroVerse (Human) to remove genes with novel junctions in &gt; 50% of GTEx samples per tissue.  </li> <li>Single-exon genes:  </li> <li>Overlapped coordinates with refTSS; excluded any with alternative TSS evidence.</li> </ul>"},{"location":"Running-SQANTI-BUGSI/#4-expert-manual-curation","title":"4. Expert Manual Curation","text":"<ul> <li>Collaborated with GENCODE annotation experts to verify no plausible alternative isoforms.</li> </ul>"},{"location":"Running-SQANTI-BUGSI/#5-final-sets","title":"5. Final Sets","text":"<ul> <li>Human: 53 BUGSI genes  </li> <li>Mouse: 37 BUGSI genes  </li> <li>Tissue\u2011specific BUGSI gene lists are available at the BUGSI portal (https://bugsi.uv.es). </li> </ul>"},{"location":"Running-SQANTI-with-the-wrapper/","title":"SQANTI3 wrapper","text":"<p>In order to run the whole pipeline, or just some part of it, through the command line, it can be directly run using <code>sqanti3 &lt;module&gt;</code> and a configuration file. The configuration file can be created by running the <code>init</code> module. This will create the default empty file <code>sqanti3_config.yaml</code>. This configuration file is fundamental for running the workflow.</p>"},{"location":"Running-SQANTI3-Quality-Control/","title":"Running SQANTI3 Quality Control","text":""},{"location":"Running-SQANTI3-Quality-Control/#table-of-contents","title":"Table of contents:","text":"<ul> <li> <p>Getting ready</p> </li> <li> <p>Arguments and parameters in SQANTI3 QC</p> </li> <li> <p>Running SQANTI3 QC</p> <ul> <li> <p>Minimal input (mandatory)</p> </li> <li> <p>Additional inputs (optional)</p> </li> </ul> </li> <li> <p>Providing short reads</p> <ul> <li> <p>Raw short read data (FASTA/FASTQ files)</p> </li> <li> <p>Short read isoform expression (Kallisto/RSEM expression files)</p> </li> <li> <p>Splice junction coverage by short reads (SJ.out.tab files)</p> </li> <li> <p>Short read mapping results (BAM files)</p> </li> </ul> </li> <li> <p>Incorporating CAGE peak data</p> </li> <li> <p>Incorporating polyA information</p> <ul> <li> <p>PolyA motif data</p> </li> <li> <p>PolyA site data</p> </li> </ul> </li> <li> <p>Supplying single or multi-sample full-length (FL) counts</p> </li> <li> <p>Selecting the metric used to aggregate TSS ratio across samples</p> </li> <li> <p>IsoAnnotLite and SQANTI3: using an existing tappAS GFF3 annotation file</p> </li> <li> <p>Parallelization</p> </li> </ul> <p></p>"},{"location":"Running-SQANTI3-Quality-Control/#getting-ready","title":"Getting ready","text":"<p>Before running SQANTI3, you will need to:</p> <p>Activate the SQANTI3 conda environment:</p> <pre><code>(base)-bash-4.1$ conda activate SQANTI3.env\n(SQANTI3.env)-bash-4.1$\n</code></pre> <p></p>"},{"location":"Running-SQANTI3-Quality-Control/#arguments-and-parameters-in-sqanti3-qc","title":"Arguments and parameters in SQANTI3 QC","text":"<p>The SQANTI3 quality control script accepts the following arguments:</p> <pre><code>usage: sqanti3_qc.py [-h] --isoforms ISOFORMS --refGTF REFGTF --refFasta\n                     REFFASTA [--min_ref_len MIN_REF_LEN] [--force_id_ignore]\n                     [--fasta] [--genename] [--short_reads SHORT_READS]\n                     [--SR_bam SR_BAM] [--novel_gene_prefix NOVEL_GENE_PREFIX]\n                     [--aligner_choice {minimap2,deSALT,gmap,uLTRA}]\n                     [-x GMAP_INDEX] [-s SITES] [--skipORF]\n                     [--orf_input ORF_INPUT] [--CAGE_peak CAGE_PEAK]\n                     [--polyA_motif_list POLYA_MOTIF_LIST]\n                     [--polyA_peak POLYA_PEAK] [--phyloP_bed PHYLOP_BED]\n                     [-o OUTPUT] [-d DIR] [--saturation]\n                     [--report {html,pdf,both,skip}] [--isoform_hits]\n                     [--ratio_TSS_metric {max,mean,median,3quartile}]\n                     [-t CPUS] [-n CHUNKS] [-l {ERROR,WARNING,INFO,DEBUG}]\n                     [--is_fusion] [-e EXPRESSION] [-c COVERAGE] [-w WINDOW]\n                     [-fl FL_COUNT] [-v] [--isoAnnotLite] [--gff3 GFF3]\n</code></pre> Arguments explanation <pre><code>Structural and Quality Annotation of Novel Transcript Isoforms\n\noptions:\n  -h, --help            show this help message and exit\n\nRequired arguments:\n  --isoforms ISOFORMS   Isoforms (FASTA/FASTQ) or GTF format. It is\n                        recommended to provide them in GTF format, but if it\n                        is needed to map the sequences to the genome use a\n                        FASTA/FASTQ file with the --fasta option.\n  --refGTF REFGTF       Reference annotation file (GTF format)\n  --refFasta REFFASTA   Reference genome (Fasta format)\n\nCustomization and filtering:\n  --min_ref_len MIN_REF_LEN\n                        Minimum reference transcript length (default: 0 bp)\n  --force_id_ignore     Allow the usage of transcript IDs non related with\n                        PacBio's nomenclature (PB.X.Y)\n  --fasta               Use when running SQANTI by using as input a\n                        FASTA/FASTQ with the sequences of isoforms\n  --genename            Use gene_name tag from GTF to define genes. Default:\n                        gene_id used to define genes\n  --short_reads SHORT_READS\n                        File Of File Names (fofn, space separated) with paths\n                        to FASTA or FASTQ from Short-Read RNA-Seq. If\n                        expression or coverage files are not provided,\n                        Kallisto (just for pair-end data) and STAR,\n                        respectively, will be run to calculate them.\n  --SR_bam SR_BAM       Directory or fofn file with the sorted bam files of\n                        Short Reads RNA-Seq mapped against the genome\n  --novel_gene_prefix NOVEL_GENE_PREFIX\n                        Prefix for novel isoforms (default: None)\n\nAligner and mapping options:\n  --aligner_choice {minimap2,deSALT,gmap,uLTRA}\n                        Select your aligner of choice: minimap2, deSALT, gmap,\n                        uLTRA (default: minimap2)\n  -x GMAP_INDEX, --gmap_index GMAP_INDEX\n                        Path and prefix of the reference index created by\n                        gmap_build. Mandatory if using GMAP unless -g option\n                        is specified.\n  -s SITES, --sites SITES\n                        Set of splice sites to be considered as canonical, in\n                        a comma separated list. (default: ATAC,GCAG,GTAG)\n\nORF prediction:\n  --skipORF             Skip ORF prediction (to save time)\n  --orf_input ORF_INPUT\n                        Input fasta to run ORF on. By default, ORF is run on\n                        genome-corrected fasta - this overrides it. If input\n                        is fusion (--is_fusion), this must be provided for ORF\n                        prediction.\n\nFunctional annotation:\n  --CAGE_peak CAGE_PEAK\n                        FANTOM5 Cage Peak (BED format, optional)\n  --polyA_motif_list POLYA_MOTIF_LIST\n                        Ranked list of polyA motifs (text, optional)\n  --polyA_peak POLYA_PEAK\n                        PolyA Peak (BED format, optional)\n  --phyloP_bed PHYLOP_BED\n                        PhyloP BED for conservation score (BED, optional)\n\nOutput options:\n  -o OUTPUT, --output OUTPUT\n                        Prefix for output files\n  -d DIR, --dir DIR     Directory for output files. (Default: Directory where\n                        the script was run.)\n  --saturation          Include saturation curves into report\n  --report {html,pdf,both,skip}\n                        Select report format: html, pdf, both, skip (default:\n                        html)\n  --isoform_hits        Report all FSM/ISM isoform hits in a separate file\n  --ratio_TSS_metric {max,mean,median,3quartile}\n                        Define which statistic metric should be reported in\n                        the ratio_TSS column (default: max)\n\nPerformance options:\n  -t CPUS, --cpus CPUS  Number of threads used during alignment by aligners.\n                        (default: 10)\n  -n CHUNKS, --chunks CHUNKS\n                        Number of chunks to split SQANTI3 analysis in for\n                        speed up (default: 1).\n  -l {ERROR,WARNING,INFO,DEBUG}, --log_level {ERROR,WARNING,INFO,DEBUG}\n                        Set the logging level INFO\n\nOptional arguments:\n  --is_fusion           Input are fusion isoforms, must supply GTF as input\n  -e EXPRESSION, --expression EXPRESSION\n                        Expression matrix (supported: Kallisto tsv)\n  -c COVERAGE, --coverage COVERAGE\n                        Junction coverage files (provide a single file, comma-\n                        delmited filenames, or a file pattern, ex:\n                        \"mydir/*.junctions\").\n  -w WINDOW, --window WINDOW\n                        Size of the window in the genomic DNA screened for\n                        Adenine content downstream of TTS (default: 20)\n  -fl FL_COUNT, --fl_count FL_COUNT\n                        Full-length PacBio abundance file\n  -v, --version         Display program version number.\n  --isoAnnotLite        Run isoAnnot Lite to output a tappAS-compatible gff3\n                        file\n  --gff3 GFF3           Precomputed tappAS species specific GFF3 file. It will\n                        serve as reference to transfer functional attributes\n\n</code></pre> <p></p> <p></p>"},{"location":"Running-SQANTI3-Quality-Control/#running-sqanti3-qc","title":"Running SQANTI3 QC","text":""},{"location":"Running-SQANTI3-Quality-Control/#minimal-input-mandatory","title":"Minimal input (mandatory)","text":"<p>This are the minimal files that you will need to run SQANTI3 QC:</p> <ul> <li> <p>Long read-defined transcriptome. It can be obtained after processing data from any of the available Third Generation Sequencing techonologies like Iso-Seq (PacBio) or Oxford Nanopore (ONT). SQANTI3 is compatible with the output of any long read-based transcriptome building pipeline, such as IsoSeq3, TALON, or FLAIR. SQANTI3 accepts it in several formats such as FASTA, FASTQ and GTF:</p> <ul> <li>GTF (default): by default, SQANTI3 expects the transcriptome to be provided as a GTF file, and we recommend to stick to this format if your transcriptome construction pipeline allows it.</li> <li>FASTA/FASTQ: if you provide your transcript sequences in FASTA or FASTQ format, you will also need to supply the <code>--fasta</code> option. In this case, a mapping step will be initially performed. SQANTI3 currently supports minimap2 (default), uLTRA, deSALT and GMAP for mapping. To select a mapper, just supply the name to the <code>--aligner_choice</code> argument.</li> </ul> </li> <li> <p>Reference transcriptome annotation in GTF format. This file will be used as reference to describe the amount of novelty across long read transcripts. Some examples of reference transcriptomes for different species can be found in GENCODE or CHESS.</p> </li> <li> <p>Reference genome in FASTA format, for example, hg38. Before running SQANTI3, make sure of the following:</p> <ul> <li>The transcriptome annotation GTF must match the provided reference genome. </li> <li>The chromosome/scaffolds names must be same in the reference annotation and the reference genome.</li> </ul> </li> </ul> <p>\u26a0\ufe0fWARNINGS:  - Before running SQANTI3, it is strongly recommended to collapse redundant transcript sequences using isoseq collapse or TAMA. To learn more about this, we suggest taking a look at our recommended long read processing workflow.</p> <ul> <li>Note that, by default, SQANTI3 expects PacBio-formatted IDs (i.e. PB.XX.XX). Users whose data was not processed using IsoSeq3 should add the <code>--force_id_ignore</code> flag to override this behavior.</li> </ul> <p></p>"},{"location":"Running-SQANTI3-Quality-Control/#additional-inputs-optional","title":"Additional inputs (optional)","text":"<ul> <li> <p>Short read data: SQANTI3 QC uses short-read data to validate several aspects of long read defined transcripts, i.e. to compute gene/isoform expression, junction coverage and TSS ratio. To learn more about the different ways in which short reads can be supplied to SQANTI3 QC, see Provding short reads section.</p> </li> <li> <p>CAGE Peak data: In SQANTI2, a CAGE peak database for the hg38 genome was provided, originally retrieved from FANTOM5. Now, we recommend to use data from refTSS. To ease usage, some versions of this annotation for several species have been uploaded to the <code>data/ref_TSS_annotation</code> folder, and we will try to keep them updated for new genome releases.</p> </li> <li> <p>polyA motif list: A ranked list of polyA motifs to find upstream of the 3' end site. See human polyA list for an example. We have included a list of motifs that can be used for mouse and human data at the <code>data/polyA_motifs/</code> folder. Please, if you know which are the most likely polyA motifs for other type of organism/clade, we would highly appreciate if you let us know.</p> </li> <li> <p>FL count information: See FL count section to include Iso-Seq FL count information for each isoform.</p> </li> <li> <p>tappAS-annotation file: when the <code>--isoAnnotLite</code> flag is activated, a GFF3 file containing isoform-level functional annotations for a reference transcriptome (e.g. Ensembl) can also be supplied via the <code>--gff3</code> flag.</p> </li> <li> <p>Intropolis junction BED file: In previous versions of SQANTI, it was provided a version of Intropolis for hg38 genome, modified into STAR junction format which is still valid.</p> </li> </ul> <p>If you don't feel like running the ORF prediction part, use <code>--skipORF</code>. Just know that all your transcripts will be annotated as non-coding.</p> <p>If you have short read data, you can run STAR to get the junction file (usually called <code>SJ.out.tab</code>, see STAR manual) and supply it to SQANTI3 as is. If you have several samples, it is recommended to provide them as separated <code>*SJ.out.tab</code> files. </p> <p>By way of example, the following command was used to run SQANTI3 with the <code>example</code> data. The input files are a subdivision of the Universal Human Reference (UHR) IsoSeq data that corresponds just to those polished and collapsed sequences located at chromosome 22. </p> <pre><code>python sqanti3_qc.py --isoforms example/UHR_chr22.gtf \\\n                     --refGTF example/gencode.v38.basic_chr22.gtf \\\n                     --refFasta example/GRCh38.p13_chr22.fasta \\\n                     --CAGE_peak data/ref_TSS_annotation/human.refTSS_v3.1.hg38.bed    \\\n                     --polyA_motif_list data/polyA_motifs/mouse_and_human.polyA_motif.txt    \\\n                     -o UHR_chr22 -d example/SQANTI3_output -fl example/UHR_abundance.tsv    \\\n                     --short_reads example/UHR_chr22_short_reads.fofn --cpus 4 --report both                     \n</code></pre> <p>It is highly recommended to run SQANTI3 using a GTF file with the Long-Read defined isoforms instead of input FASTA/FASTQ file with their sequences. If you ran isoseq collapse, the obtained <code>*collapsed.gff</code> file is actually in GFF2 format (equivalent to GTF), so you can use it as is. If you provide the sequences, a mapping step will be needed and the decisions took by the mapping algorithm will affect the final results. </p> <p></p>"},{"location":"Running-SQANTI3-Quality-Control/#providing-short-reads","title":"Providing short reads","text":"<p>Short read data can be supplied to SQANTI3 in several ways:</p> <ul> <li>Raw short-read data: for users who may want SQANTI3 to compute all short read-based attributes internally without the need to perform any additional pre-processing, short read FASTA/FASTQ files can be provided using the dedicated argument (see Raw short read data section below).</li> </ul> <p>Alternatively, users may supply pre-processed short read data in one or more of these formats:</p> <ul> <li> <p>Short read-based transcript expression: see Short read isoform expression section below for details on how to include pre-computed, short read-based expression files into SQANTI3 QC (RSEM or Kallisto output files or a user-defined expression matrix).</p> </li> <li> <p>Splice junction coverage by short-reads: short reads can be mapped to the genome using STAR to obtain junction coverage information, included in the the <code>SJ.out.tab</code> file (see Splice junction coverage section for details).</p> </li> <li> <p>Short read BAMs: should be obtained by mapping short reads against the reference genome using a splice-aware mapper, such as STAR. SQANTI3 QC will use this information to compute the TSS ratio.</p> </li> </ul> <p></p>"},{"location":"Running-SQANTI3-Quality-Control/#raw-short-read-data-fastafastq-files","title":"Raw short read data (FASTA/FASTQ files)","text":"<p>Matching RNA-Seq data (i.e. obtained from the same samples as your long-read data) can be supplied to SQANTI3 in the form of FASTA/FASTQ files via the <code>--short_reads</code> argument. The expected file format is a File Of File Names (.fofn), which is a text file that contains the paths of the Short-Read RNA-Seq data with one line per replicate and separated by one space in the case of paired-end data. It should look like this:</p> <pre><code>/path/to/replicate1.R1.fastq /path/to/replicate1.R2.fastq\n/path/to/replicate2.R1.fastq /path/to/replicate2.R2.fastq\n</code></pre> <p>STAR and kallisto will be run to automatically calculate splice-junction coverage, isoform expression and the <code>ratio_TSS</code> attribute, a metric that quantifies the differences of mean coverage 100bp upstream and downstream the reported TSS. </p> <p>Please note that, if you are going to use the <code>--short_reads</code> option, you should provide enough memory and computational resources for mapping and quantifying.</p> <p>\u26a0\ufe0fWarning: Kallisto will only be run if paired-end data is provided. If you wish to run Kallisto on single-end data, you may do it before running SQANTI3 and supply the isoform expression matrix as indicated below.</p> <p></p>"},{"location":"Running-SQANTI3-Quality-Control/#short-read-isoform-expression","title":"Short read isoform expression","text":"<p>Users can supply their pre-computed isoform expression via the <code>--expression</code> argument. Depending on whether this information is provided as one or multiple files, two formats are supported:  - If you input one expression file per sample, you can provide several expression data files as a chain of comma-separated paths or by providing a directory where ONLY expression data is present. Accepted formats include the output of Kallisto and RSEM (see below). - Alternatively, it is possible to provide a pre-computed expression matrix. The matrix should be a tab-separated file with transcripts as rows and samples/replicates as columns. Transcript identifiers must match the ones included in the input long read-defined transcriptome, and the name for that column must be <code>ID</code>. The rest of the columns in the header can be named as desired, and should correspond to the sample/replicate identifier.</p>"},{"location":"Running-SQANTI3-Quality-Control/#kallisto-expression-files","title":"Kallisto expression files","text":"<p>Kallisto expression files have the following format:</p> <pre><code>target_id   length  eff_length  est_counts  tpm\nPB.1.1  1730    1447.8  0   0\nPB.1.3  1958    1675.8  0   0\nPB.2.1  213 54.454  0   0\nPB.2.2  352 126.515 0   0\nPB.3.1  153 40.3918 0   0\nPB.4.1  1660    1377.8  0   0\nPB.5.1  2767    2484.8  0   0\n</code></pre>"},{"location":"Running-SQANTI3-Quality-Control/#rsem-expression-files","title":"RSEM expression files","text":"<p>RSEM expression files have the following format:</p> <pre><code>transcript_id   gene_id length  effective_length        expected_count  TPM     FPKM    IsoPct  posterior_mean_count    posterior_standard\n_deviation_of_count     pme_TPM pme_FPKM        IsoPct_from_pme_TPM     TPM_ci_lower_bound      TPM_ci_upper_bound      FPKM_ci_lower_boun\nd       FPKM_ci_upper_bound\nPB.1.1  PB.1    1516    1369.11 8.00    0.05    0.22    100.00  8.00    0.00    0.06    0.25    100.00  0.0233365       0.0984532       0.\n0981584 0.413561\nPB.10.1 PB.10   1101    954.11  0.00    0.00    0.00    0.00    0.00    0.00    0.01    0.04    100.00  4.80946e-08     0.0283585       2.\n01809e-07       0.11905\nPB.100.1        PB.100  979     832.11  0.00    0.00    0.00    0.00    6.62    6.60    0.08    0.35    4.00    3.51054e-06     0.241555 1.47313e-05      1.01397\nPB.100.2        PB.100  226     81.11   20.18   2.26    9.47    100.00  16.84   5.20    1.99    8.36    96.00   0.559201        3.45703 2.\n34572   14.5141\n</code></pre> <p></p>"},{"location":"Running-SQANTI3-Quality-Control/#splice-junction-coverage-by-short-reads","title":"Splice junction coverage by short reads","text":"<p>If you have short read data, you can run STAR to get the junction file (usually called <code>SJ.out.tab</code>) and supply it to SQANTI3 via the <code>-c</code> argument. It is possible to use a different mapper, however, SQANTI3 requires that the format of the junction is similar to that of STAR's <code>SJ.out.tab</code> file (see below). </p> <p>As described in the STAR manual:</p> <p>SJ.out.tab contains high confidence collapsed splice junctions in tab-delimited format. Note that STAR defines the junction start/end as intronic bases, while many other software define them as exonic bases.  The columns in <code>SJ.out.tab</code> have the following meaning: - column 1: chromosome - column 2: first base of the intron (1-based) - column 3: last base of the intron (1-based) - column 4: strand (0: undefined, 1: +, 2: -) - column 5: intron motif: 0: non-canonical; 1: GT/AG, 2: CT/AC, 3: GC/AG, 4: CT/GC, 5:AT/AC, 6: GT/AT - column 6: 0: unannotated, 1: annotated in the splice junctions database. Note that in 2-pass mode, junctions detected in the 1st pass are reported as annotated, in addition to annotated junctions from GTF. - column 7: number of uniquely mapping reads crossing the junction - column 8: number of multi-mapping reads crossing the junction - column 9: maximum spliced alignment overhang The filtering for this output file is controlled by the <code>--outSJfilter</code> parameters.</p> <p>If you have several samples, we recommend providing them as separated <code>*SJ.out.tab</code> files instead of combined into a single file. To provide several files, you can follow different strategies:  - Supply the path of the directory where all the <code>SJ.out.tab</code> are situated. - Provide each of their individual paths separated by a comma. - Use a wildcard to provide all paths at the same time, e.g. <code>/path/to/*my_suffix.tsv</code>.</p> <p></p>"},{"location":"Running-SQANTI3-Quality-Control/#short-read-mapping-results-bam-files","title":"Short read mapping results (BAM files)","text":"<p>If you used the <code>-c</code> argument to provide coverage information, but you want to calculate <code>ratio_TSS</code> values for each isoform, SQANTI3 QC will still require you to supply short read mapping information. Therefore, we recommend users to supply the BAM files obtained as a result of mapping short reads to the genome via the <code>--SR_bam</code> option. Otherwise, you may supply short reads as raw data to SQANTI3 and have all pre-processing steps done internally, however, keep in mind that this will take longer as well as require more memory/computational resources.</p> <p></p>"},{"location":"Running-SQANTI3-Quality-Control/#incorporating-cage-peak-data-cage_peak","title":"Incorporating CAGE peak data (<code>--CAGE_peak</code>)","text":"<p>To perform quality control of the Transcription Start Site (TSS), users may provide CAGE peak data. This is particularly relevant given that 5' RNA degradation can generate variability in the TSS that can be mistaken for a novel TSS.</p> <p>CAGE peak data must be provided as a BED file, where:</p> <ul> <li>Column 1 contains the chromosome (chr1, chr2...).</li> <li>Column 2 contains the zero-based index start coordinate.</li> <li>Column 3 contains one-based index end coordinate.</li> <li>Column 6 contains strand information.</li> </ul> <p>The BED file needs to be supplied to <code>sqanti3_qc.py</code> via the <code>--CAGE_peak</code> argument.</p> <p>Please, note that public CAGE peak data for human and mouse from the refTSS database is supplied in SQANTI3's <code>data</code> folder.</p> <p>SQANTI3 QC will use this data to validate the transcript's TSS. First, it will evaluate whether the TSS of the different long read-defined transcripts fall inside a CAGE peak (<code>within_CAGE_peak</code> column). Then, it will calculate the distance to the nearest detected CAGE peak (<code>dist_to_CAGE_peak</code> column in the output <code>*_classification.txt</code> file). A detailed glossary of classification file columns can be found here.</p> <p></p>"},{"location":"Running-SQANTI3-Quality-Control/#incorporating-polya-information","title":"Incorporating polyA information","text":"<p>To perform quality control of the Transcription Termination Site (TTS), users may provide polyA motif or polyA site/peak information. SQANTI3 QC will use this data to create several descriptors regarding the presence of the TTS within polyA sites/motifs, as well as the distance to them, if detected.</p> <p></p>"},{"location":"Running-SQANTI3-Quality-Control/#polya-motif-data-polya_motif_list","title":"PolyA motif data (<code>--polyA_motif_list</code>)","text":"<p>The polyA motif list should be supplied in the form of a text file. The most common polyA motifs for human and mouse are supplied in the SQANTI3 <code>data</code> folder (see here).</p> <p>The list of polyA motifs with the <code>--polyA_motif_list</code> parameter in <code>sqanti3_qc.py</code>.</p> <p>If a polyA motif is identified at the 3' end of the transcript, the <code>polyA_motif_found</code> column in the classification file will be <code>TRUE</code>. In addition, SQANTI3 returns the sequence (<code>polyA_motif</code>) and the distance (<code>polyA_dist</code>) to the closest polyA motif detected. A detailed glossary of classification file columns can be found here.</p> <p></p>"},{"location":"Running-SQANTI3-Quality-Control/#polya-site-data-polya_peak","title":"PolyA site data (<code>--polyA_peak</code>)","text":"<p>Complementary to polyA motif information, polyA site data can be supplied. It must be supplied as a BED file, where:</p> <ul> <li>Column 1 contains the chromosome (chr1, chr2...).</li> <li>Column 2 contains the zero-based index start coordinate.</li> <li>Column 3 contains one-based index end coordinate.</li> <li>Column 6 contains strand information.</li> </ul> <p>For human, mouse, and worm, you can download public polyA site data from the PolyASite atlas. Note, however, that the chromosomes in the BED files are missing the \"chr\" prefix. You will need to modify the downloaded BED file as follows:</p> <pre><code>sed -i 's/^/chr/' atlas.clusters.2.0.GRCh38.96.bed\n</code></pre> <p>The polyA site BED file must be supplied to <code>sqanti3_qc.py</code> via the <code>--polyA_peak</code> argument.</p> <p>Using this information, SQANTI3 will write out the distance to the closest polyA site/peak (<code>dist_to_polyA_site</code> column) and whether the transcript's TTS was found inside a polyA site/peak (<code>within_polyA_site</code> column) to the output <code>*_classification.txt</code> file. A detailed glossary of classification file columns can be found here.</p> <p></p>"},{"location":"Running-SQANTI3-Quality-Control/#supplying-single-or-multi-sample-full-length-fl-counts-fl_count","title":"Supplying single or multi-sample full-length (FL) counts (<code>--fl_count</code>)","text":"<p><code>sqanti3_qc.py</code> supports single or multi-sample FL counts from PacBio Iso-Seq pipeline. There are three acceptable formats.</p>"},{"location":"Running-SQANTI3-Quality-Control/#single-sample-fl-count","title":"Single Sample FL Count","text":"<p>A single sample FL Count file is automatically produced by the Iso-Seq With Mapping pipeline in SMRTLink/SMRTAnalysis with the following format:</p> <pre><code>#\n# -----------------\n# Field explanation\n# -----------------\n# count_fl: Number of associated FL reads\n# norm_fl: count_fl / total number of FL reads, mapped or unmapped\n# Total Number of FL reads: 1065\n#\npbid    count_fl        norm_fl\nPB.1.1  2       1.8779e-03\nPB.1.2  6       5.6338e-03\nPB.1.3  3       2.8169e-03\nPB.2.1  3       2.8169e-03\nPB.3.1  2       1.8779e-03\nPB.4.1  8       7.5117e-03\n\n</code></pre>"},{"location":"Running-SQANTI3-Quality-Control/#multi-sample-chained-fl-count","title":"Multi Sample Chained FL Count","text":"<p>A multi-sample FL Count file produced by the chain_samples.py script in Cupcake will have the following format:</p> superPBID sample1 sample2 PB.1.2 3 NA PB.2.1 2 NA PB.3.1 2 2 PB.3.2 5 3 PB.3.3 5 2 <p>This is a tab-delimited file.</p>"},{"location":"Running-SQANTI3-Quality-Control/#multi-sample-demux-fl-count","title":"Multi Sample Demux FL Count","text":"<p>A multi-sample Demux FL Count file produced by the demux_isoseq_with_genome.py script in Cupcake will have the following format:</p> <pre><code>id,sample1,sample2\nPB.1.1,3,10\nPB.1.2,0,11\nPB.1.3,4,4\n</code></pre> <p>This is a comma-delimited file.</p>"},{"location":"Running-SQANTI3-Quality-Control/#fl-count-information-in-the-sqanti3-qc-output","title":"FL count information in the SQANTI3 QC output","text":"<p>For each sample provided through the <code>--fl_count</code> option, <code>sqanti3_qc.py</code> will create a column in the <code>*_classification.txt</code> output file that is <code>FL.&lt;sample&gt;</code>. Note that this is the raw FL count provided. The sum of all the FL reads accross the samples associated to one transcript will be recorded in th <code>FL</code> column of the <code>*_classification.txt</code> output file.</p> <p>When plotted, the script SQANTI3_report.R will convert the FL counts to TPM using the formula:</p> <pre><code>                           raw FL count for PB.X.Y in sample1\nFL_TPM(PB.X.Y,sample1) = ------------------------------------- x 10^6\n                               total FL count in sample1\n</code></pre> <p>Two additional columns, <code>FL_TPM.&lt;sample&gt;</code> and <code>FL_TPM.&lt;sample&gt;_log10</code> will be added and output to a new classification file with the suffix <code>*_classification_TPM.txt</code>. Please, do not mix up <code>*_classification_TPM.txt</code>  and <code>*_classification.txt</code> files. The one used in subsequent scripts (filtering, future isoAnnot, etc.) will be the <code>_classification.txt</code> one. A detailed glossary of classification file columns can be found here.</p> <p></p>"},{"location":"Running-SQANTI3-Quality-Control/#selecting-the-metric-used-to-aggregate-tss-ratio-across-samples","title":"Selecting the metric used to aggregate TSS ratio across samples","text":"<p>As of v5.2, SQANTI3 includes the <code>--ratio_TSS_metric</code> argument, which can be used to tweak the results in the <code>TSS_ratio</code> column of the classification.txt file. Briefly, SQANTI3 calculates the TSS ratio metric for all supplied short-read samples and replicates, and then summarizes the results to provide a single TSS ratio value.</p> <p>The following options are available: - <code>max</code> (default): uses the maximum value among the short-read samples and replicates supplied.  - <code>mean</code>: mean value of samples and replicates is used.  - <code>median</code>: median value of samples and replicates is used. - <code>3rd quartile</code>: the 3rd quartile value of samplesl and replicates is used.</p> <p>When aiming to discover novel and/or rare TSS, this metric will ensure that underrepresented sites will not be disregarded just because they are only captured in one sample. <code>median</code> and <code>3rd quartile</code>, on the other hand, allow the user to enforce different levels of robustness, preventing the metric from being driven by outliers and favoring widely-detected TSS to be preserved after QC. <code>mean</code> values, on the other hand, provide a balance between both scenarios in situations in which the degree of TSS novelty of the sample is unknown.</p> <p></p>"},{"location":"Running-SQANTI3-Quality-Control/#isoannotlite-and-sqanti3-using-an-existing-tappas-annotation-file-gff3","title":"IsoAnnotLite and SQANTI3: using an existing tappAS annotation file (<code>--gff3</code>)","text":"<p>When the <code>--isoAnnotLite</code> flag is supplied to SQANTI3 QC, the tool will run IsoAnnotLite internally. IsoAnnotLite is a Python script designed to use the SQANTI3 QC output to generate the input for tappAS, i.e. tappAS-compatible  GFF3 file (see \"Annotation features file format\" section in the tappAS overview).</p> <p>If you want IsoAnnotLite to perform positional transfer of functional features, you will also need to provide a pre-annotated tappAS GFF3 file via the <code>--gff3</code> argument. By doing this, functional feature information will be added to your long read-defined transcriptome, unlocking tappAS functional and feature-level analyses. You can find all functional annotation files available for tappAS here. </p> <p>Note that, if no pre-annotated tappAS GFF3 file is provided (e.g. because there is no file available for your species), IsoAnnotLite will only perform structural information transfer, but a tappAS-like GFF3 file containing this structural information will still be generated. Therefore, in this case, users will still be able to load their data into tappAS for isoform-level expression analyses.</p> <p>\u26a0\ufe0fWarning: we are aware that some of the tappAS GFF3 files correspond to old transcriptome releases of reference databases (ENSEMBL, RefSeq, etc.). We are currently working on updating these annotations to later transcriptome versions. </p> <p></p>"},{"location":"Running-SQANTI3-Quality-Control/#parallelization","title":"Parallelization","text":"<p>There are two options related to parallelization:</p> <ul> <li>The <code>-t</code> (<code>--cpus</code>) parameter designates the number of CPUs used by the aligners for long and short reads. If your have supplied your transcriptome a GTF file and you do not provide short-read FASTA/FASTQ files, the <code>-t</code> option has no effect.</li> <li>The <code>-n</code> (<code>--chunks</code>) parameter divides the input transcriptome (GTF or FASTA/FASTQ) into chunks and runs SQANTI3 in parallel for each fragment, then combining the results into one classification and junctions file. </li> </ul> <p>Note that both of this parameters can be combined, for instance, if you have set <code>-t 30 -n 10</code>, then each chunk will get (30/10=3) CPUs.</p>"},{"location":"Running-SQANTI3-filter/","title":"Running SQANTI3 filter","text":""},{"location":"Running-SQANTI3-filter/#table-of-contents","title":"Table of contents:","text":"<ul> <li> <p>Rules filter: removing artifacts using the SQANTI3 output and user-defined rules</p> <ul> <li>Running the rules filter</li> <li>Default filter</li> <li>Making your own filter</li> </ul> </li> <li> <p>Rules filter output</p> </li> <li> <p>Machine learning filter: removing artifacts using a random forest classifier</p> <ul> <li>Running the machine learning filter</li> <li>True Positive (TP) and True Negative (TN) sets</li> <li>Partitioning of the training data (model training/testing)</li> <li>Probability threshold to define Isoforms/Artifacts</li> <li>Classification file columns excluded from the ML filter</li> <li>Excluding additional data columns from the filter</li> <li>Intra-priming filter</li> <li>Forcing the removal/retention of specific isoform groups</li> <li>Exceptions to running the SQANTI3 ML filter</li> </ul> </li> <li> <p>Machine learning filter output</p> <ul> <li>Input-related files</li> <li>Model-related files</li> <li>Test set files</li> <li>Filter report</li> <li>Classification file</li> <li>Inclusion list and filtering of SQANTI QC output files</li> </ul> </li> </ul> <p></p>"},{"location":"Running-SQANTI3-filter/#rules-filter-removing-artifacts-using-the-sqanti3-output-and-user-defined-rules","title":"Rules filter: removing artifacts using the SQANTI3 output and user-defined rules","text":"<p> SQANTI3 filter has been reshaped to allow users to supply their own set of rules. These will be used to accept or discard an isoform based on the attributes obtained through SQANTI3 QC. To define those rules, the user will need to create a JSON file specifying which SQ3 attributes and thresholds are to be used for filtering and, therefore, the properties of the transcripts that are to be included in the final transcriptome. </p> <p></p> <p></p>"},{"location":"Running-SQANTI3-filter/#running-the-rules-filter","title":"Running the rules filter","text":"<p> The rules filter only needs a SQANTI3 classification file to work. To run it, just execute <code>sqanti3_filter.py</code> providing the <code>rules</code> argument followed by the path to the SQANTI3 <code>*_classification.txt</code> file:</p> <pre><code>python sqanti3_filter.py rules --sqanti_class path/to/classification.txt \n</code></pre> <p>Using the optional arguments, the script can be set up to filter several file formats (such as FASTA, GTF and BAM) and remove the isoforms that were catalogued as artifacts based on these user-defined rules. This option is designed to make it easy for users filter the files from the SQANTI3 QC output, enabling quick transcriptome curation.</p> <p>These are the arguments accepted by <code>sqanti3_filter.py rules</code>:</p> <pre><code>usage: sqanti3_filter.py rules [-h] --sqanti_class SQANTI_CLASS [--isoAnnotGFF3 ISOANNOTGFF3] [--filter_isoforms FILTER_ISOFORMS] [--filter_gtf FILTER_GTF] [--filter_sam FILTER_SAM]\n                               [--filter_faa FILTER_FAA] [-o OUTPUT] [-d DIR] [--skip_report] [-e] [-v] [-c CPUS] [-l {ERROR,WARNING,INFO,DEBUG}] [-j JSON_FILTER]\n</code></pre>  Arguments description <pre><code>Rules filter selected\n\noptions:\n  -h, --help            show this help message and exit\n\nRequired arguments:\n  --sqanti_class SQANTI_CLASS\n                        SQANTI3 QC classification file.\n\nInput options:\n  --isoAnnotGFF3 ISOANNOTGFF3\n                        isoAnnotLite GFF3 file to be filtered\n  --filter_isoforms FILTER_ISOFORMS\n                        fasta/fastq isoform file to be filtered\n  --filter_gtf FILTER_GTF\n                        GTF file to be filtered\n  --filter_sam FILTER_SAM\n                        SAM alignment of the input fasta/fastq\n  --filter_faa FILTER_FAA\n                        ORF prediction faa file to be filtered by SQANTI3\n\nOutput options:\n  -o OUTPUT, --output OUTPUT\n                        Prefix for output files.\n  -d DIR, --dir DIR     Directory for output files. Default: ./sqanti3_results\n  --skip_report         Skip creation of a report about the filtering\n\nFiltering options:\n  -e, --filter_mono_exonic\n                        All mono-exonic transcripts are automatically filtered\n\nExtra options:\n  -v, --version         Display program version number.\n  -c CPUS, --cpus CPUS  Number of CPUs to use. Default: 4\n  -l {ERROR,WARNING,INFO,DEBUG}, --log_level {ERROR,WARNING,INFO,DEBUG}\n                        Set the logging level.\n                        Default: INFO\n\nRules specific options:\n  -j JSON_FILTER, --json_filter JSON_FILTER\n                        JSON file where filtering rules are expressed. Rules must be set taking into account that attributes described in the filter will be present in those isoforms that should be kept.\n                        Default: /home/pabloati/Programs/sqanti3/src/utilities/filter/filter_default.json\n</code></pre> <p></p> <p></p>"},{"location":"Running-SQANTI3-filter/#default-filter","title":"Default filter","text":"<p>Following the same criteria as in previous versions of SQANTI3, we hereby provide a default set of rules for the filter. These are equivalent to running the old <code>sqanti3_RulesFilter.py</code> script. However, we strongly advise users to closely inspect the properties of their transcriptome and define their own filter based on the results obtained during QC. Keep in mind as well that any isoform that has a missing value in any of the conditions of a rule will be considered an artifact. This means that <code>NA</code> the likes will be treated as fails. </p> <p>When no JSON file is provided to the rules filter, this is the set of filtering rules used by default:</p> <ul> <li>If a transcript is a FSM, it is kept unless the 3' end is unreliable because of a possible intrapriming event. <ul> <li>We consider that an isoform is likely to be an artifact of intrapriming if in the 20bp downstream the annotated Transcription Terminating Site (TTS) there are 12 or more adenines at the genomic level. That means that following the TTS there is a stretch of nucleotides with at least a 60% A's. </li> </ul> </li> <li>If a transcript is not a FSM, it is kept only if all of the criteria below are met: <ul> <li>(1) 3' end is not an intrapriming artifact.</li> <li>(2) does not have a junction that is labeled as RT-Switching.</li> <li>(3) all junctions are either canonical or have short read coverage above the <code>-c</code> threshold.</li> </ul> </li> </ul> <p>This filter is supplied in the <code>utilities/filter/filter_default.json</code> file:</p> <pre><code>{\n    \"full-splice_match\": [\n        {\n            \"perc_A_downstream_TTS\":[0,59]\n        }\n    ],\n    \"rest\": [\n        {\n            \"perc_A_downstream_TTS\":[0,59],\n            \"RTS_stage\":\"FALSE\",\n            \"all_canonical\":\"canonical\"\n        },\n        {   \n            \"perc_A_downstream_TTS\":[0,59],\n            \"RTS_stage\":\"FALSE\",\n            \"min_cov\":3\n        }\n     ]\n}\n</code></pre> <p> </p>"},{"location":"Running-SQANTI3-filter/#making-your-own-filter","title":"Making your own filter","text":"<p> As of SQANTI3 version 5.0, it is possible to supply a user-defined filter including as many rules as desired. To do it, the user needs to create a JSON file defining which characteristics make an isoform reliable. </p>"},{"location":"Running-SQANTI3-filter/#defining-rules-and-requisites","title":"Defining rules and requisites","text":"<p>Specifically, for each structural category, the user should build an array of objects (or rules). A rule is made of one or more requisites, all of which must be fulfilled for an entry to be considered a true Isoform (they will be evaluated as AND in terms of logical operators). If different rules (i.e. sets of requisites) are defined for the same structural category, they will be treated independently of one another. In that case, to pass the filter, transcripts will need to pass at least one of these independent rules (they will be evaluated as OR in terms of logical operators). </p> <p>Of note, it is also possible to set rules for the rest of structural categories, i.e. those rules will be applied to any structural category for which there isn't a rule established. In that case, users will need to define the rule using the category name <code>rest</code>.</p> <p>Here is a basic scheme of how to define rules and the list of requisites that make up a rule in a JSON file:</p> <pre><code>{\n    \"structural_category\": [\n        {\n            \"numeric_column_name\":[0,100]\n            \"character_column_name\": [\"accepted_value1\", \"accepted_value2\"]\n        }\n     ]\n}\n</code></pre> <p>Rules can be set for any numeric or character column in the classification file: - Numeric values: in this case, it is possible to define an interval (<code>[X,Y]</code>) or set just the lower limit (<code>X</code>). Please, take into account that the limit values will be included.  - Character and logical columns: such as <code>subcategory</code>, <code>RTS_stage</code> or <code>all_canonical</code>. In this case, users can simply establish which terms will be accepted. Of note, users may want to accept several of the values in the column (for instance, several subcategories). If so, the requisite can be defined as an array, and the filter will keep the entries if any of those values are present in the specified column.</p>"},{"location":"Running-SQANTI3-filter/#user-defined-rules-json-file-example","title":"User-defined rules (JSON file) example","text":"<p>As an example, let's say that we want to define a custom filter that will keep only isoforms that pass these rules:</p> <ul> <li>FSM: Keep if the isoform is:<ul> <li>NOT a potential intrapriming product (less than 60% in the <code>perc_A_downstream_TTS</code> column).</li> </ul> </li> <li>ISM: Keep if:<ul> <li>It is larger than 2kb and shorter than 15kb AND</li> <li>It is catalogued within the \"3prime_fragment\", \"5prime_fragment\" or \"internal_fragment\" subcategories.</li> </ul> </li> <li>NIC: Keep if:<ul> <li>All the splice junctions are canonical OR covered at least by 10 short reads.</li> </ul> </li> <li>NNC: Keep if:<ul> <li>All the splice junctions are canonical OR covered at least by 10 short reads AND</li> <li>The absolute distance to the closest annotated TSS and TTS is 50bp or less.</li> </ul> </li> <li>Rest of the categories: Keep if :<ul> <li>All the splice junctions are canonical and they are not suspicious of being an RT-Switching (RTS) artifact.</li> <li>It is a coding transcript.</li> <li>It is not an intrapriming product.</li> <li>It is not a mono-exon transcript.</li> </ul> </li> </ul> <p>The JSON file for that precise filter will look like this:</p> <pre><code>{\n    \"full-splice_match\": [\n        {\n            \"perc_A_downstream_TTS\":[0,59]\n        }\n    ],\n    \"incomplete-splice_match\":[\n        {\n            \"length\":[2001,14999],\n            \"subcategory\": [\"3prime_fragment\", \"5prime_fragment\", \"internal_fragment\"]\n        }\n    ],\n    \"novel_in_catalog\":[\n        {\n            \"all_canonical\": \"canonical\"\n        },\n        {\n            \"min_cov\": 10\n        }\n    ],\n    \"novel_not_in_catalog\":[\n        {\n            \"all_canonical\": \"canonical\",\n            \"diff_to_gene_TSS\":[-50,50],\n            \"diff_to_gene_TTS\": [-50,50]            \n        },\n        {\n            \"min_cov\": 10,\n            \"diff_to_gene_TSS\":[-50,50],\n            \"diff_to_gene_TTS\": [-50,50] \n        }\n    ],\n    \"rest\": [\n        {\n            \"RTS_stage\":\"FALSE\",\n            \"all_canonical\":\"canonical\",\n            \"coding\": \"coding\",\n            \"perc_A_downstream_TTS\":[0,59],\n            \"exons\": 2\n        }\n     ]\n}\n\n</code></pre> <p></p>"},{"location":"Running-SQANTI3-filter/#rules-filter-output","title":"Rules filter output","text":"<p> The main SQANTI rules filter output files are:</p> <ul> <li><code>*_RulesFilter_result_classification.txt</code>: New classification file with an extra column called \"filter_result\" that will classify all the entries as Isoform or Artifact.</li> <li><code>*_inclusion-list.txt</code>: Text file with the IDs of the isoforms that passed the filter.</li> <li><code>*_filtering_reasons.txt</code>: TSV file with 3 columns:<ul> <li>(1) Isoform ID of the isoform that was. filtered out</li> <li>(2) Structural Category</li> <li>(3) Reason why the isoform was discarded as an artifact. If an isoform is catalogued as Artifact because it doesn't fulfill several rules, there will be multiple lines in this file regarding that isoform.</li> </ul> </li> <li><code>*_SQANTI3_filter_report.pdf</code>: A PDF report with some plots describing the performance of the filtering.</li> </ul> <p></p>"},{"location":"Running-SQANTI3-filter/#machine-learning-filter-removing-artifacts-using-a-random-forest-classifier","title":"Machine learning filter: removing artifacts using a random forest classifier","text":"<p> SQANTI3 incorporates an automated filter based on a random forest classifier,  which is designed to discriminate potential artifacts from true isoforms without the need for user-defined rules or manually-set thresholds. </p> <p>Briefly, this classifier learns high and low quality attributes from a True  Positive (TP) and True Negative (TN) transcript set, building a model that  discriminates artifacts and isoforms based on TN and TP properties.  The filter returns a modified  version of the <code>*_classification.txt</code> file (named <code>*_MLresult_classification.txt</code>). The new table will include a <code>filter_result</code>  column with the label <code>Isoform</code> or <code>Artifact</code>, which will be the result of the  random forest classifier.</p> <p>\u26a0\ufe0f Disclaimer: we hereby provide instructions to run the filter and a comprehensive  description of its parameters. While we have included recommendations on how to best tune  them to obtain optimal results, users are encouraged to try several configurations of  the filter to find the best way to run it for their particular dataset. \u26a0\ufe0f</p> <p></p> <p></p>"},{"location":"Running-SQANTI3-filter/#running-the-machine-learning-filter","title":"Running the machine learning filter","text":"<p> Similarly to the rules filter, the machine learning filter (ML filter) can be  run using the <code>sqanti3_filter.py</code> script by providing the <code>ML</code> argument followed by the path to the SQANTI <code>*_classification.txt</code> file (output by <code>sqanti3_qc.py</code>):</p> <pre><code>python sqanti3_filter.py ml path/to/classification.txt \n\n</code></pre> <p>A brief tutorial on how to run the SQANTI3 ML filter for an example dataset can  be found here.</p> <p>These are the parameters and arguments accepted by <code>sqanti3_filter.py ML</code>:</p> <pre><code>usage: sqanti3_filter.py ml [-h] --sqanti_class SQANTI_CLASS [--isoAnnotGFF3 ISOANNOTGFF3]\n                            [--filter_isoforms FILTER_ISOFORMS] [--filter_gtf FILTER_GTF]\n                            [--filter_sam FILTER_SAM] [--filter_faa FILTER_FAA] [-o OUTPUT] [-d DIR]\n                            [--skip_report] [-e] [-v] [-c CPUS] [-l {ERROR,WARNING,INFO,DEBUG}]\n                            [-t PERCENT_TRAINING] [-p TP] [-n TN] [-j THRESHOLD] [-f] [--intermediate_files]\n                            [-r REMOVE_COLUMNS] [-z MAX_CLASS_SIZE] [-i INTRAPRIMING]\n</code></pre>  Arguments description <pre><code>ML filter selected\n\noptions:\n  -h, --help            show this help message and exit\n\nRequired arguments:\n  --sqanti_class SQANTI_CLASS\n                        SQANTI3 QC classification file.\n\nInput options:\n  --isoAnnotGFF3 ISOANNOTGFF3\n                        isoAnnotLite GFF3 file to be filtered\n  --filter_isoforms FILTER_ISOFORMS\n                        fasta/fastq isoform file to be filtered\n  --filter_gtf FILTER_GTF\n                        GTF file to be filtered\n  --filter_sam FILTER_SAM\n                        SAM alignment of the input fasta/fastq\n  --filter_faa FILTER_FAA\n                        ORF prediction faa file to be filtered by SQANTI3\n\nOutput options:\n  -o OUTPUT, --output OUTPUT\n                        Prefix for output files.\n  -d DIR, --dir DIR     Directory for output files. Default: ./sqanti3_results\n  --skip_report         Skip creation of a report about the filtering\n\nFiltering options:\n  -e, --filter_mono_exonic\n                        All mono-exonic transcripts are automatically filtered\n\nExtra options:\n  -v, --version         Display program version number.\n  -c CPUS, --cpus CPUS  Number of CPUs to use. Default: 4\n  -l {ERROR,WARNING,INFO,DEBUG}, --log_level {ERROR,WARNING,INFO,DEBUG}\n                        Set the logging level.\n                        Default: INFO\n\nMachine Learning specific options:\n  -t PERCENT_TRAINING, --percent_training PERCENT_TRAINING\n                        Proportion of the data that goes to training (parameter p of the function createDataPartition).                     \n                        Default: 0.8\n  -p TP, --TP TP        Path to file containing the list of the TP transcripts, one ID by line, no header (optional). If not supplied, it will be generated from input data.\n  -n TN, --TN TN        Path to file containing the list of the TN transcripts, one ID by line, no header (optional). If not supplied, it will be generated from input data.\n  -j THRESHOLD, --threshold THRESHOLD\n                        Machine Learning probability threshold to classify transcripts as positive isoforms.         \n                        Default: 0.7\n  -f, --force_fsm_in    Forces retaining FMS transcripts regardless of ML filter result (FSM are threfore automatically classified as isoforms).\n  --intermediate_files  Outputs ML filter intermediate files.\n  -r REMOVE_COLUMNS, --remove_columns REMOVE_COLUMNS\n                        Path to single-column file (no header) containing the names of the columns in SQ3's classification.txt file that are to be excluded during random forest training (optional).\n  -z MAX_CLASS_SIZE, --max_class_size MAX_CLASS_SIZE\n                        Maximum number of isoforms to include in True Positive and True Negative sets. TP and TN sets will be downsized to this value if they are larger.\n                        Default: 3000\n  -i INTRAPRIMING, --intrapriming INTRAPRIMING\n                        Adenine percentage at genomic 3' end to flag an isoform as intra-priming. Default: 60\n</code></pre> <p></p> <p>We next provide a detailed description of each of the ML filter parameters in order to help users understand how to best apply it to their own data.</p> <p></p>"},{"location":"Running-SQANTI3-filter/#true-positive-tp-and-true-negative-tn-sets","title":"True Positive (TP) and True Negative (TN) sets","text":"<p> As stated above, the random forest classifier model needs to be trained on a subset of isoforms from the transcriptome. This will include a set of True Positive isoforms -that is, isoforms that are reliable enough for the classifier to learn the properties  of a real isoform- and a set of True Negative isoforms -that is, isoforms that can be considered low-quality or false, from which the classifier will learn what constitutes an artifact or false-positive isoform-.</p> <p>Although the ML filter includes built-in selection of training data from specific  SQANTI categories, it also accepts user-defined TN and TP sets (<code>--TN [-n]</code>  and <code>--TP [-p]</code> parameters, respectively). These should be provided as  single-column files (with no header) containing the IDs of the selected isoforms,  and will be used to train and test the random forest classifier.</p> <p>If not provided, the SQANTI ML filter will use the following as  built-in TP and TN sets by default:</p> <ul> <li>TP: all Reference Match (RM) isoforms in the transcriptome (multi-exon only).  RM are an FSM subcategory in which the TSS and TTS of the isoform are within +/-50bp of the TSS/TTS of the reference associated transcript (see the category description page for details). If there are less than 250 RM isoforms, all FSMs will be taken as TP.</li> <li>TN: all Novel Not in Catalog (NNC) isoforms that have at least one non-canonical junction (multi-exon only). If there are less than 250 isoforms in this group (normally because there are not enough non-canonical junctions in the transcriptome), all NNC  isoforms will be taken as TN.</li> </ul> <p>Note that both user-defined and built-in training data will be subset if the number of isoforms in the TP or TN isoform sets is larger than the other. By default,  SQANTI3 will downsize the larger set to match the smaller of the two sizes. Downsizing is performed by random sampling. When using the built-in option, and given this random sampling step, TP and TN lists will be written out as part of the SQANTI ML filter output.</p> <p>Users may change the <code>--max_class_size [-z]</code> parameter to set a maximum number of isoforms to include in the TP and TN sets. By default, TP and TN lists will be downsized to 3000 transcripts if they are larger than this,  no matter if they were user-defined or generated internally.</p> <p></p>"},{"location":"Running-SQANTI3-filter/#partitioning-of-the-training-data-model-trainingtesting","title":"Partitioning of the training data (model training/testing)","text":"<p> TP and TN isoform sets need to be split into training and test data to correctly generate the random forest model. Using the <code>--percent_training</code> or <code>-t</code> parameter, users can specify the proportion of the data that is used for training. By default, 80% of the isoforms will be used for training (which is equivalent to supplying  <code>-t 0.8</code>). The remaining 20% will be used to test the model.</p> <p>The ML filter uses functions from the <code>caret</code> R package to build and test the random forest classifier. Briefly, the model training/test includes the following internal  steps:</p> <ol> <li>Data partitioning via the <code>createDataPartition()</code> function.</li> <li>Cross-validation (10x) using the <code>trainControl()</code> function.</li> <li>Model training using the <code>train()</code> function.</li> <li>Testing of the model using the <code>predict()</code> function from the <code>stats</code> package  in base R.</li> <li>Output model statistics using several other functions from the <code>caret</code> package  (see the ML filter output section for details).</li> </ol> <p>Warning: after training, the model will be stored as an <code>.RData</code> object in  the specified output folder. If the filter is re-run on the same directory, SQANTI will detect that a model already exists, skipping the training step and applying the extant model to perform the Isoform/Artifact classification on the input data.  This is useful on occasions where a user wants to apply an already-generated  model to a different transcriptome; however, if you wish to train a new model, you will need to delete/move/rename the previous model object.</p> <p></p>"},{"location":"Running-SQANTI3-filter/#probability-threshold-to-define-isoformsartifacts","title":"Probability threshold to define Isoforms/Artifacts","text":"<p> Ultimately, flagging transcripts as Isoforms or Artifacts is based on the  random forest probability to correctly classify a transcript into either group. These probabilities are included in the <code>POS_MLprob</code> and <code>NEG_MLprob</code>  columns of the output <code>_MLresult_classification.txt</code> file. Intuitively:</p> <ul> <li><code>POS_MLprob</code> is the probability of classifying the transcript as an Isoform.</li> <li><code>NEG_MLprob</code> is the probability of classifying the transcript as an Artifact, and is equivalent to <code>1 - POS_MLprob</code>.</li> </ul> <p>The SQANTI ML filter will assign the Artifact and Isoform labels based on a  probability threshold parameter supplied via the <code>--threshold</code> or <code>-j</code> argument. By default, the filter is more stringent on the Isoform condition than it is on the Artifact condition, that is: by default, transcripts will be considered  isoforms when <code>POS_MLprob</code> is larger than 0.7. </p> <p>This results in some artifacts having <code>POS_MLprob &gt; 0.5</code> (which can be  counter-intuitive). Of course, in this scenario, the filter will exclude more  transcripts than when using the usual <code>POS_MLprob &gt; NEG_MLprob</code> approach.  However, users may reproduce this lenient filter by lowering the threshold to 0.5.</p> <p></p>"},{"location":"Running-SQANTI3-filter/#classification-file-columns-excluded-from-the-ml-filter","title":"Classification file columns excluded from the ML filter","text":"<p> Due to their lack of importance for artifact definition (or to prevent them from having unwanted effects on the filtering), the following columns are removed  from the classification table prior to running the SQANTI ML filter:</p> <ul> <li>Chromosome and strand info (<code>chrom</code>, <code>strand</code>)</li> <li>Reference gene/transcript info (<code>associated_gene</code>, <code>associated_transcript</code>)</li> <li>Structural information about the reference or the transcript (<code>ref_length</code>, <code>ref_exons</code>, <code>ORF_length</code>, <code>CDS_length</code>, <code>CDS_start</code>, <code>CDS_end</code>, <code>CDS_genomic_start</code>, <code>CDS_genomic_end</code>).</li> <li>Sequence information (<code>seq_A_downstream_TTS</code>, <code>ORF_seq</code>).</li> <li>SQANTI category (<code>structural_category</code>, <code>subcategory</code>).</li> </ul> <p>Moreover, the following columns are excluded when TP and TN sets are built by the ML filter, instead of supplied by the user: - Redundant junction information (<code>all_canonical</code>) to prevent overfitting due to NNC non-canonical or NNC transcripts being used as a TN set. - Redundant distance to TSS/TTS information (all <code>dist_*</code> columns in the classification file) to prevent bias towards reference-similar isoforms when RM are used as a TP set.</p> <p></p>"},{"location":"Running-SQANTI3-filter/#excluding-additional-data-columns-from-the-filter","title":"Excluding additional data columns from the filter","text":"<p> The SQANTI ML filter incorporates the option to exclude columns from the  _classification.txt file from model training to prevent filtering based on  them. These should be provided as a single-column file including the column names exactly as they are named in the classification file. A path to this file should then be supplied via the <code>--remove_columns</code> or <code>-r</code> argument.</p> <p>This is particularly useful to prevent overfitting during model training.  In particular, there may be situations in which users wish to define TP and TN  sets based on the values of specific SQ3 columns. We recommend that these are,  in turn, excluded from the ML filter to prevent them from gaining too much  importance during Isoform/Artifact classification. </p> <p>Warning: we always encourage testing several ML filter configurations and TP/TN sets  before making a final decision on which are the artifacts in your transcriptome.</p> <p></p>"},{"location":"Running-SQANTI3-filter/#intra-priming-filter","title":"Intra-priming filter","text":"<p> The ML filter script in SQANTI3 includes a simple threshold-based filter to prevent potential intra-priming artifacts from remaining in the transcriptome, which is not specifically considered by the ML filter. Still, note that the <code>perc_A_downstream_TTS</code> column, which is used to flag transcripts as potentially resulting from intra-priming, is considered during random forest training.</p> <p>To apply it, users may supply the maximum percentage of adenines (\"A\" nucleotides) that is to be allowed in the genome sequence region immediately following the end of the transcript (i.e. the TTS). This can be provided via the <code>--intrapriming</code> or <code>-i</code>  argument, resulting in <code>perc_A_downstream_TTS &gt; i</code> isoforms being flagged as  intra-priming artifacts. By default, transcripts containing more than 60% A's at the genomic 3' end will be flagged.</p> <p></p>"},{"location":"Running-SQANTI3-filter/#forcing-the-removalretention-of-specific-isoform-groups","title":"Forcing the removal/retention of specific isoform groups","text":"<p> 1. Full-splice match (FSM) transcripts can be excluded from the ML filter and therefore retained by providing the <code>--force_fsm_in</code> or <code>-f</code> argument. By default, FSM will be run through the filter along with the isoforms from the rest of the  structural categories.</p> <ol> <li>All mono-exonic transcripts can be automatically removed by providing the  <code>--filter_mono_exonic</code> or <code>-e</code> parameter. Note that mono-exon transcripts will not be evaluated by the ML filter (only by the intra-priming filter).</li> </ol> <p></p>"},{"location":"Running-SQANTI3-filter/#exceptions-to-running-the-sqanti3-ml-filter","title":"Exceptions to running the SQANTI3 ML filter","text":"<p> The random forest classifier cannot/will not be run in any of the following scenarios:</p> <ul> <li>All transcripts in the long read-defined transcriptome are classified as mono-exon. The ML filter can only be applied to multi-exon transcripts.</li> <li>One (or both) of the user-defined TP and TN sets have less than 40 isoforms.</li> <li>One of the default TP and TN categories has less than 40 isoforms.  This applies when no user-defined TP and TN sets are provided.</li> </ul> <p>However, even in scenarios where no ML-based filtering can be applied, the intra-primming filter will still be applied to all input transcripts.</p> <p></p>"},{"location":"Running-SQANTI3-filter/#sqanti-ml-filter-output","title":"SQANTI ML filter output","text":"<p>The SQANTI ML filter output files are written to the path specified using the <code>--dir</code> or <code>-d</code> argument, also appending the prefix provided via the <code>--output</code>  or <code>-o</code> argument.</p> <p>An example of the ML filter output can be found under the <code>example/MLfilter_output</code> folder, which is included in the main SQANTI3 directory (see our example dataset tutorial for details).</p> <p>The following output files are generated after running the filter:</p> <p></p>"},{"location":"Running-SQANTI3-filter/#input-related-files","title":"Input-related files","text":"<p> - <code>params.txt</code>: two-column file including the name of the argument and the value that was used to run the filter. - <code>TP_list.txt</code> and <code>TN_list.txt</code>: a single-column text file including the  IDs of the isoforms used as TP and TN (generated only when no user-defined sets were provided).</p> <p>The supplied prefix will be appended to the filenames above.</p> <p></p>"},{"location":"Running-SQANTI3-filter/#model-related-files","title":"Model-related files","text":"<p> - <code>randomforest.RData</code>: R object containing the trained random forest model. - <code>classifier_variagble-importance_table.txt</code>: two-column text file including the names of the variables that were used for classification and a numeric value indicating their importance in the random forest classifier. - <code>intermediate_*_MLinput_table.txt</code>: training-ready classification table. SQANTI ML filter performs a series of modifications of the classification table to  enable running of the training/test steps. These include handling of <code>NAs</code>, value formatting, column removal, etc. This file will only be output if the <code>--intermediate_files</code> argument is supplied. Note that this file is NOT intented for downstream anaylsis.</p> <p></p>"},{"location":"Running-SQANTI3-filter/#test-set-files","title":"Test set files","text":"<p> All include the <code>testSet_</code> prefix:</p> <ul> <li><code>stats.txt</code>: all statistics for the model testing.</li> <li><code>ROC_curve.pdf</code>.</li> <li><code>confusionMatrix.txt</code>: confusion matrix obtained after running the trained model on the test set.</li> <li><code>summary.txt</code>: summary statistics of the model testing, namely sensitivity, specificity and AUROC.</li> </ul> <p></p>"},{"location":"Running-SQANTI3-filter/#filter-report","title":"Filter report","text":"<p> The ML filter automatically returns a PDF report. This includes filter summary tables and plots as well as  one diagnostic plot per variable used by the random forest classifier. This allows an evaluation of the behaviour of  transcripts flagged as isoforms and artifacts in the light of each of the variables that were considered  relevant to discriminate both.</p> <p>Supplying the <code>--skip_report</code> flag will deactivate the report.</p> <p></p>"},{"location":"Running-SQANTI3-filter/#classification-file","title":"Classification file","text":"<p> The <code>MLresult_classification.txt</code> constitutes a modified classification file  including the results of the ML and intra-priming filters. The following columns are added:</p> <ul> <li><code>POS_MLprob</code> and <code>NEG_MLprob</code>, described above (see probability threshold section). </li> <li><code>ML_classifier</code> column, in which <code>ML_classifier == Positive</code> corresponds to transcripts in which <code>POS_MLprob &gt; t</code> (therefore flagged as Isoforms by the ML filter).</li> <li><code>intra_priming</code> column, in which <code>intrapriming == TRUE</code> corresponds to transcripts flagged as intra-priming atrifacts.</li> <li><code>filter_result</code> column, including the combined result for the ML and intra-priming filters. An isoform will be <code>filter_result == Isoform</code> if it passed both the ML and intra-priming filters. </li> </ul> <p>In the specific case of mono-exonic transcripts, passing the intra-priming filter  will be enough to be considered an isoform, as long as they are not removed using  the <code>-e</code> argument. Similarly, all FSM transcripts will be flagged as true isoforms if the <code>-f</code> option is provided.</p> <p></p>"},{"location":"Running-SQANTI3-filter/#inclusion-list-and-filtering-of-sqanti-qc-output-files","title":"Inclusion list and filtering of SQANTI QC output files","text":"<p> Finally, <code>inclusion-list.txt</code> is a single-column file including the IDs of the transcripts  classified as true isoforms (i.e. flagged as <code>Isoform</code> in the <code>filter_result</code> column). This list will be used to provide filtered versions of supplied SQANTI QC output files.  Use the <code>--isoAnnotGFF3</code>, <code>--isoforms</code>, <code>--gtf</code>, <code>--faa</code> and <code>--sam</code> arguments to provide  each of the files you wish to obtain filtered.</p>"},{"location":"Running-SQANTI3-from-the-wrapper/","title":"Running SQANTI3 from the wrapper","text":""},{"location":"Running-SQANTI3-from-the-wrapper/#sqanti3-v54-simplified-execution-with-wrapper-script-and-configuration-file","title":"SQANTI3 v5.4: Simplified Execution with Wrapper Script and Configuration File","text":"<p>As of release v5.4, SQANTI3 introduces a streamlined way to run the pipeline using a unified wrapper script and a YAML configuration file. This update aims to simplify SQANTI3 execution by consolidating all parameters for a given run\u2014from quality control (QC) through filtering and rescue\u2014into a single, easily managed file.</p>"},{"location":"Running-SQANTI3-from-the-wrapper/#recommended-setup","title":"Recommended Setup","text":"<p>To ensure a smooth experience with SQANTI3, follow these recommendations:</p> <ul> <li> <p>Add SQANTI3 to your PATH:   Make the wrapper script accessible system-wide by either adding the SQANTI3 directory to your PATH or creating a symbolic link to the <code>sqanti3</code> script in a directory already in your PATH.</p> </li> <li> <p>Use a configuration file per experiment:   Maintain one YAML configuration file per experiment. This allows you to tweak parameters directly from the command line for each run.</p> </li> </ul> Adding SQANTI3 to the PATH in Ubuntu  You can add the wrapper script to your PATH in two ways:  - **Option 1: Add the SQANTI3 directory to your PATH**     ```bash     export PATH=$PATH:/path/to/SQANTI3     ```     Add this line to your `.bashrc` file to make it persistent across sessions.  - **Option 2: Create a symbolic link**     ```bash     ln -s /path/to/SQANTI3/sqanti3 /usr/local/bin/sqanti3     ```  <p></p>"},{"location":"Running-SQANTI3-from-the-wrapper/#configuration-file","title":"Configuration File","text":"<p>The configuration file is written in YAML (\u26a0\ufe0f must use the <code>.yaml</code> extension). It contains all arguments and parameters required by the SQANTI3 modules and flags to select which modules (qc, filter, rescue) to run. For the filter and rescue modules, you can specify whether to use rules-based or machine learning approaches.</p> <p>Structure: - Common options: Shared across all modules (e.g., reference genome, maximum threads). - Module-specific options: Parameters unique to QC, filter, or rescue.</p> <p>Creating a Configuration Template: Generate a template with default parameters using:</p> <pre><code>sqanti3 init -c \n</code></pre> <p>If no filename is provided, it defaults to <code>sqanti3_config.yaml</code>.</p> <p>Overriding Parameters: You can override configuration values directly from the command line using the <code>-a</code> flag:</p> <pre><code>sqanti3 init -c sqanti3_config.yaml -a cpus=8 dir=sqanti3_results\n</code></pre> <p>The <code>-a</code> flag can also be used when running SQANTI3 to temporarily override config values for a specific run.</p> <p>View Available Arguments: Use the <code>-h</code> flag after a module name to list all available arguments and their default values.</p> \u2753Example Configuration File <pre><code>main:\n  refGTF: ''\n  refFasta: ''\n  cpus: 4\n  dir: sqanti3_results\n  output: isoforms\n  log_level: INFO\nqc:\n  enabled: true\n  options:\n    isoforms: ''\n    min_ref_len: 0\n    force_id_ignore: false\n    fasta: false\n    genename: false\n    short_reads: ''\n    SR_bam: ''\n    novel_gene_prefix: ''\n    aligner_choice: minimap2\n    gmap_index: ''\n    sites: ATAC,GCAG,GTAG\n    skipORF: false\n    orf_input: ''\n    CAGE_peak: ''\n    polyA_motif_list: ''\n    polyA_peak: ''\n    phyloP_bed: ''\n    saturation: false\n    report: html\n    isoform_hits: false\n    ratio_TSS_metric: max\n    chunks: 1\n    is_fusion: false\n    expression: ''\n    coverage: ''\n    window: 20\n    fl_count: ''\n    isoAnnotLite: false\n    gff3: ''\nfilter:\n  enabled: true\n  options:\n    common:\n      sqanti_class: sqanti3_results/isoforms_classification.txt\n      isoAnnotGFF3: ''\n      filter_isoforms: sqanti3_results/isoforms_corrected.fasta\n      filter_gtf: sqanti3_results/isoforms_corrected.gtf\n      filter_sam: ''\n      filter_faa: sqanti3_results/isoforms_corrected.faa\n      skip_report: false\n      filter_mono_exonic: false\n    rules:\n      enabled: true\n      options:\n        json_filter: /home/pabloati/Programs/sqanti3/src/utilities/filter/filter_default.json\n    ml:\n      enabled: false\n      options:\n        percent_training: 0.8\n        TP: ''\n        TN: ''\n        threshold: 0.7\n        force_fsm_in: false\n        intermediate_files: false\n        remove_columns: ''\n        max_class_size: 3000\n        intrapriming: 60\nrescue:\n  enabled: true\n  options:\n    common:\n      filter_class: sqanti3_results/isoforms_RulesFilter_result_classification.txt\n      rescue_isoforms: sqanti3_results/isoforms_corrected.fasta\n      rescue_gtf: sqanti3_results/isoforms.filtered.gtf\n      refClassif: ''\n      rescue_mono_exonic: all\n      mode: automatic\n    rules:\n      enabled: true\n      options:\n        json_filter: /home/pabloati/Programs/sqanti3/src/utilities/filter/filter_default.json\n    ml:\n      enabled: false\n      options:\n        random_forest: ''\n        threshold: 0.7\n</code></pre> <p></p>"},{"location":"Running-SQANTI3-from-the-wrapper/#running-sqanti3","title":"Running SQANTI3","text":"<p>After creating your configuration file, you can run SQANTI3 in two main ways:</p> <ul> <li> <p>Run all activated modules (QC, filter, rescue): <code>bash     sqanti3 all -c sqanti3_config.yaml</code></p> </li> <li> <p>Run a specific module: <code>bash     sqanti3 qc -c sqanti3_config.yaml     sqanti3 filter -c sqanti3_config.yaml     sqanti3 rescue -c sqanti3_config.yaml</code></p> </li> </ul> <p>Override parameters for a single run:</p> <pre><code>sqanti3 qc -c sqanti3_config.yaml -a short_reads=/path/to/short_reads.fastq dir=/path/to/output\n</code></pre> <p>This command temporarily changes the short reads file and output directory for this run only.</p> \u2753Help message <pre><code>usage: sqanti3 [-c CONFIG] [--dry-run] [-a ARGUMENTS [ARGUMENTS ...]] [-h] [-l {ERROR,WARNING,INFO,DEBUG}] {all,qc,filter,rescue,init}\n\nPython wrapper for SQANTI3 pipeline.\n\npositional arguments:\n  {all,qc,filter,rescue,init}  Action to perform\n\noptions:\n  -c CONFIG, --config CONFIG   Path to the configuration file (default: sqanti3_config.yaml)\n  --dry-run                   Print the commands that would be executed\n  -a ARGUMENTS [ARGUMENTS ...], --arguments ARGUMENTS [ARGUMENTS ...]\n                              Non-default arguments to pass to the SQANTI3 modules\n  -h, --help                  Show the help message and exit\n  -l {ERROR,WARNING,INFO,DEBUG}, --log_level {ERROR,WARNING,INFO,DEBUG}\n                              Set the logging level (default: INFO)\n</code></pre> <p></p>"},{"location":"Running-SQANTI3-rescue/","title":"Running SQANTI3 rescue","text":""},{"location":"Running-SQANTI3-rescue/#table-of-contents","title":"Table of contents:","text":"<ul> <li> <p>Introduction  <ul> <li>Motivation</li> </ul> <li> <p>Rescue strategy</p> </li> <li> <p>Running SQ3 rescue</p> <ul> <li> <p>Input files and arguments <li> <p>Rules rescue arguments <li> <p>Machine learning rescue arguments <li> <p>Rescue output <ul> <li> <p>Common rescue output files <li> <p>Rules-specific output <li> <p>Machine learning-specific output <p></p>"},{"location":"Running-SQANTI3-rescue/#introduction","title":"Introduction","text":"<p>As of SQANTI3 v5.1, a new module has been added to the SQANTI3 workflow for transcriptome characterization and quality control: SQANTI3 rescue. </p> <p>The SQANTI3 rescue algorithm is designed to be run after transcriptome filtering and uses the long read-based evidence  provided by discarded isoforms (i.e. artifacts) to recover transcripts in the associated reference transcriptome.  The idea behind this strategy is to avoid losing transcripts/genes that are detected as expressed by long read sequencing, but whose start/end/junctions could not be confidently validated using orthogonal data, resulting in the removal of those genes/transcripts from the transriptome. More details about this can be found in the Motivation section below.</p> <p>In particular, during the rescue, SQANTI3 will try to confidently assign each discarded artifact to the best matching reference transcript. As a result, SQANTI3 rescue will generate an expanded transcriptome GTF including a set of reference transcripts as well as the long read-defined isoforms that passed the filter. Optionally, requantification can be performed to reassign expression values to the rescued isoforms.</p> <p></p>"},{"location":"Running-SQANTI3-rescue/#motivation","title":"Motivation","text":"<p> \u26a0\ufe0fTo be completed\u26a0\ufe0f</p> <p></p>"},{"location":"Running-SQANTI3-rescue/#sqanti3-rescue-strategy","title":"SQANTI3 rescue strategy","text":"<p> Here is a summary of the SQ3 rescue workflow:</p> <p></p> <p>The SQANTI3 rescue algorithm consists in the following steps:</p>"},{"location":"Running-SQANTI3-rescue/#1a-automatic-rescue","title":"1.a Automatic rescue","text":"<p>As explained above, the rescue strategy in SQ3 was conceived to recover transcriptome diversity lost during filtering. This, among other things, means verifying that mone of the reference-supported junction chains that were initially detected by long-reads are lost due to stringent artifact removal.</p> <p>To achieve this during automatic rescue, all reference transcripts that were represented by at least one FSM in the original post-QC transcriptome are first retrieved -note that this information is available in the <code>associated_transcript</code> column of the <code>*_classification.txt</code> file. Then, those reference transcripts for which all FSM representatives were removed by the filter are rescued.</p> <p>The previous analytic decision is justified because, in practice, any case where all FSMs with the same <code>associated_transcript</code> are removed can be interpreted as follows: 1) the TSS and/or TTS of the long read-defined transcript is different from that of the matching  reference transcript, however, it could not be validated by SQ3 QC-supplied orthogonal data; and 2) the junctions are identical to those found in the reference, which can be interpreted as evidence that this isoform is real. As a result, SQ3 will not rescue any of the discarded FSMs, but the <code>associated_transcript</code> from the reference.</p> <p>By default, SQANTI3 Rescue runs under <code>--mode automatic</code>. As a result, this is the only rescue step that SQANTI3 Rescue performs. The complete algorithm can be run by the <code>--mode full</code> argument.</p> <p></p>"},{"location":"Running-SQANTI3-rescue/#1b-selection-of-rescue-candidate-and-target-transcripts","title":"1.b Selection of rescue candidate and target transcripts","text":"<p>In spite of its potential to achieve the goals that we set for the rescue, the previous strategy does not consider ISM, NIC or NNC artifacts. These will be included in the rescue candidate group, i.e. transcripts classified as artifacts for which SQANTI3 will try to find a matching reference transcript to include in the final, curated transcriptome.</p> <ul> <li> <p>For ISM artifact transcripts, there are two possible situations:</p> </li> <li> <p>There will be cases where the same discarded reference transcript is supported by FSM and ISM. ISM artifacts with an FSM artifact counterpart will therefore be \"collapsed\" into the rescued reference transcript during the automatic rescue step.</p> </li> <li> <p>Conversely, there will be <code>associated_transcript</code> references that are only supported by one or more ISM. Those ISM artifacts that constituted evidence of a non-FSM supported reference will therefore be included in the rescue candidate list.</p> </li> <li> <p>For novel transcripts from the NIC and NNC categories, since there is no associated transcript information, all transcripts classified as artifacts will be included in the rescue candidate list.</p> </li> </ul> <p>As a result, we consider all reference or long read-defined transcripts from genes that have at least one rescue candidate to be rescue targets.</p>"},{"location":"Running-SQANTI3-rescue/#2-mapping-of-candidates-to-targets","title":"2. Mapping of candidates to targets","text":"<p>SQ3 rescue next tries to find matches between each rescue target and its same-gene candidates based on sequence similarity. To achieve this, we perform an internal mapping step using minimap2. In it, rescue candidates are considered to be \"reads\" and rescue targets are used as a \"reference genome\" in which each transcript sequence constitutes a different \"chromosome\". </p> <p>To map candidates, we use the <code>map-hifi</code> option in minimap2 and the <code>-a -x</code> parameters:</p> <pre><code>minimap2 --secondary=yes -ax map-hifi rescue_targets.fasta rescue_candidates.fasta &gt; mapped_rescue.sam\n</code></pre> <p>Finally, all candidate-target pairs obtained during mapping -referred to as mapping hits- are obtained from the output SAM file regardless of whether they are primary or secondary alignments.</p> <p></p>"},{"location":"Running-SQANTI3-rescue/#3-application-of-sq3-filter-to-the-reference-transcriptome","title":"3. Application of SQ3 filter to the reference transcriptome","text":"<p>Validation of transcripts using orthogonal sources of data is an important part of the SQANTI3 philosophy. In consequence, the rescue strategy in SQ3 includes a validation step for all reference rescue targets before considering them for inclusion in the transcriptome, since no QC information is available for them (in contrast to long read-defined targets).</p> <p>This requires users to run SQANTI3 quality control on the reference transcriptome and supply the output <code>*_classification.txt</code> file to SQANTI3 rescue using the <code>--refClassif</code> (<code>-k</code>) flag. This must be done using the same orthogonal data files that were used when running SQANTI3 QC for the long read-transcriptome, since the rescue is based on the assumption that the same evidence is required to validate all rescue targets.</p> <p>\u26a0\ufe0f Disclaimer: note that this is a temporary solution -we are currently working on implementing an option to run this step internally as a part of the rescue-, however, we are aware that the same reference may be used for multiple transcriptomes, therefore, this option will remain active to save runtime and resources. \u26a0\ufe0f</p> <p>Using the supplied reference classification file, SQ3 rescue will next apply SQ3 filter to the reference transcriptome. The filter to be applied will be specified by the <code>rules</code> or <code>ml</code> flags used when running the rescue. This means that, if you run SQ3 machine learning-based filter, you should also run the rescue using the <code>ml</code> option (and the same is true for the rules filter).</p> <p></p>"},{"location":"Running-SQANTI3-rescue/#4-rescue-by-mapping","title":"4. Rescue-by-mapping","text":"<p>In the final rescue step, hereby referred to as rescue-by-mapping, mapping hits (i.e. candidate-target pairs obtained during mapping) and reference transcriptome filter results are combined to generate a final list of reference transcripts to be rescued.  </p> <p>This part of the rescue can be divided into the following tasks/criteria:</p> <ul> <li> <p>SQ3 filtering of targets: first, candidate-target pairs are removed if the rescue target did not pass the filter (ML or rules).  If the user is working with the rules filter, this will mean that the reference (or long-read) target transcript did not pass the rules defined in the JSON file. If the user is working with the ML filter, this will mean that the target transcript did not pass the specified ML probability threshold. In the case of the ML filter, however, only the target transcript(s) with maximum ML probability are selected to continue in the rescue.</p> </li> <li> <p>Select reference targets: as explained above, both long read-defined and reference target transcripts are considering during mapping. As a result, rescue candidates (i.e. artifacts) can match to either of these transcripts. From this step onwards, however, only targets selected from the reference transcriptome are considered. This is done to avoid introducing redundancy in the final transcriptome: if a rescue candidate's perfect match was another long read-defined counterpart from the same gene, there is no need to include another transcript as a rescued representative, since the best matching transcript is already part of the transcriptome.</p> </li> <li> <p>Remove redundant reference transcripts: during rescue, there is a chance that some of the reference transcripts that we wish to include in our transcriptome is already represented by an FSM from the same gene (or that it has been already retrieved during automatic rescue). In this situation, target reference transcripts that are already represented by a long read-defined isoform are not to be included in the transcriptome in order to avoid increasing redundancy. In other words -and similarly to what was previously stated-, these are cases in which the artifact's (i.e. rescue candidate) best matching transcript is already represented by an isoform in the transcriptome.</p> </li> </ul> <p>After performing this last filter of the rescue target list, SQ3 rescue outputs a list of rescued reference transcripts, which are then added to the long-read transcriptome GTF.</p> <p></p> <p></p>"},{"location":"Running-SQANTI3-rescue/#5-requantification","title":"5. Requantification","text":"<p>The requantification is applied to each transcript following one of the four scenarios:</p> <p>1) A transcript was not impacted by either filtering or the rescue step; the expression level of such a transcript is intact. </p> <p>2) A transcript was flagged by the filter as an artifact and was not rescued; the expression level is ignored.</p> <p>3) A transcript was initially discarded and later rescued by the reference transcript; the initial expression level is transferred to the reference transcript. </p> <p>4) One of the qualifying transcripts did not pass the redundancy test and was not included in the final rescue isoforms list, meaning that the transcript is already represented by a transcript model that was not affected by the filtering step. The expression levels from artifacts are summed up with the expression levels of the unaffected transcript.</p>"},{"location":"Running-SQANTI3-rescue/#running-sq3-rescue","title":"Running SQ3 rescue","text":"<p>Similarly to the SQANTI3 filter, the SQANTI3 rescue is designed as a  dual implementation, depending on whether the rules or the machine learning filter was previously run. Therefore, the <code>sqanti3_rescue.py</code> script requires a flag to be provided to activate either the <code>ml</code> or <code>rules</code> specific rescue.</p> <pre><code>usage: sqanti3_rescue.py [-h] {ml,rules} ...\n\nRescue artifacts discarded by the SQANTI3 filter, i.e. find closest match for\nthe artifacts in the reference transcriptome and add them to the\ntranscriptome.\n\npositional arguments:\n  {ml,rules}  \n\noptional arguments:\n  -h, --help  show this help message and exit\n</code></pre> <p></p>"},{"location":"Running-SQANTI3-rescue/#input-files-and-arguments","title":"Input files and arguments","text":"<p> Regardless of the rescue mode that is selected, SQ3 has the following common arguments, all of which are mandatory: - SQANTI filter classification: The SQANTI3 classification file of the isoforms after the filter step, which has the new columns that indicates wyhich isoforms is an artifact and which is a true isoform.</p> <ul> <li> <p>Long read-defined isoforms: should be the FASTA file generated by SQANTI3 QC (<code>*_corrected.fasta</code>). The isoform sequences will be used to extract rescue candidates and targets for mapping, and must be supplied via the <code>--rescue_isoforms</code> argument.</p> </li> <li> <p>Long read-defined transcriptome annotation (filtered): should be the GTF file output by SQANTI3 filter (<code>*.filtered.gtf</code>). Rescued transcripts will be appended to this GTF file to generate the final curated transcriptome. This file must be supplied via the <code>--rescue_gtf</code> argument.</p> </li> <li> <p>Reference transcriptome annotation: reference GTF used to run SQANTI3 QC. This file will be used to extract rescue targets for mapping, and must be supplied via the <code>--refGTF</code> (or <code>-g</code>) argument.</p> </li> <li> <p>Reference transcriptome classification file generated after running SQANTI3 QC on the reference transcriptome, which must be done previously to running the rescue and using the same orthogonal data as for long read-defined transcriptome QC. This file must be supplied via the <code>--refClassif</code> (or <code>-k</code>) argument and will be used to evaluate reference rescue target support (see details above).</p> </li> <li> <p>Counts file containing expression values of transcript models before SQANTI3 filtering and rescue. This file is required if the <code>--requant</code> (<code>-q</code>) module is used. It must include two columns: the first for the isoform ID and the second for the corresponding expression value. Column headers can vary. Provide this file using the <code>--counts</code> (or <code>-c</code>) argument; it will be used to re-evaluate the expression values of the filtered and rescued transcript models.</p> </li> </ul> <p>Additionally, the following parameters can be set to modify the behavior of the rescue algorithm:</p> <ul> <li>Rescue mode: the <code>--mode</code> argument can be used to extend the rescue algorithm to non-FSM artifacts by supplying <code>--mode full</code>. By default (<code>--mode automatic</code>), only the automatic rescue step is performed, enabling the rescue of high-confidence reference isoforms.</li> <li>Define rescue for mono-exon transcripts: the <code>-e</code> flag can be used to determine whether (and how) to perform the rescue on mono-exonic transcripts. The following options can be supplied:</li> <li><code>all</code> (default): all mono-exon transcripts classified as artifacts will be considered as rescue candidates, regardless of the category that they are classified into.</li> <li><code>fsm</code>: mono-exonic transcripts will only be considered for the rescue if they belong to the full-splice match (FSM) category. In this case, mono-exons will be rescued via the automatic rescue strategy.</li> <li> <p><code>none</code>: do not consider mono-exonic transcripts for the rescue (all mono-exons classified as artifacts will be discarded and no reference representatives included in the final transcriptome).</p> </li> <li> <p>Output directory and outfile prefix: the output directory can be set via the <code>-d</code> flag (default: current directory). Output files will be named using the prefix provided using the <code>-o</code> argument (default: SQANTI3).</p> </li> </ul> <p></p>"},{"location":"Running-SQANTI3-rescue/#rules-rescue-arguments","title":"Rules rescue arguments","text":"<p> In addition to the common arguments, the rules rescue requires the following specific files:</p> <ul> <li>Rules JSON file: using the <code>-j</code> flag, the user must provide the JSON file used for running SQANTI3 rules filter on the long read-defined transcriptome. This same set of rules will be applied to the reference transcriptome to evaluate the reliability of reference rescue targets. Note that, to achieve this, SQANTI3 rescue requires the classification file output after running SQANTI3 QC on the reference to be provided via the <code>--refClassif</code> argument.</li> </ul> <p>All in all, these are the arguments accepted by <code>sqanti3_rescue.py rules</code>:</p> <pre><code>usage: sqanti3_rescue.py rules [-h] --filter_class FILTER_CLASS --refGTF REFGTF --refFasta REFFASTA [--rescue_isoforms RESCUE_ISOFORMS] [--rescue_gtf RESCUE_GTF] [-k REFCLASSIF] [-e {all,fsm,none}]\n                               [--mode {automatic,full}] [-o OUTPUT] [-d DIR] [-c CPUS] [-v] [-l {ERROR,WARNING,INFO,DEBUG}] [-j JSON_FILTER] [-q] [-c EXPRESSION_VALUES]\n</code></pre> Arguments explanation <pre><code>Rescue for rules-filtered transcriptomes.\n\noptions:\n  -h, --help            show this help message and exit\n\nRequired arguments:\n  --filter_class FILTER_CLASS\n                        SQANTI filter (ML or rules) output classification file.\n  --refGTF REFGTF       Full path to reference transcriptome GTF used when running SQANTI3 QC.\n  --refFasta REFFASTA   Full path to reference genome FASTA used when running SQANTI3 QC.\n\nInput options:\n  --rescue_isoforms RESCUE_ISOFORMS\n                        FASTA file output by SQANTI3 QC (*_corrected.fasta), i.e. the full long read transcriptome.\n  --rescue_gtf RESCUE_GTF\n                        GTF file output by SQANTI3 filter (*.filtered.gtf).\n  -k REFCLASSIF, --refClassif REFCLASSIF\n                        Full path to the classification file obtained when running SQANTI3 QC on the reference transcriptome.                        \n                        Mandatory when running the rescue on full mode\n  -q, --requant\n                        Run requantification to reassign expression values to the rescued transcripts.\n  -c, --counts\n                        Full path to the file containing transcript expression values before SQANTI3 filtering and rescue.\n\n\nCustomization options:\n  -e {all,fsm,none}, --rescue_mono_exonic {all,fsm,none}\n                        Whether or not to include mono-exonic artifacts in the rescue.                    \n                        Default: all\n  --mode {automatic,full}\n                        If 'automatic' (default), only automatic rescue of FSM artifacts will be performed.                     \n                        If 'full', rescue will include mapping of ISM, NNC and NIC artifacts to find potential replacement isoforms.\n\nOutput options:\n  -o OUTPUT, --output OUTPUT\n                        Prefix for output files.\n  -d DIR, --dir DIR     Directory for output files. Default: Directory where the script was run.\n\nExtra options:\n  -c CPUS, --cpus CPUS  Number of CPUs to use. Default: 4\n  -v, --version         Display program version number.\n  -l {ERROR,WARNING,INFO,DEBUG}, --log_level {ERROR,WARNING,INFO,DEBUG}\n                        Set the logging level INFO\n\nRules specific options:\n  -j JSON_FILTER, --json_filter JSON_FILTER\n                        Full path to the JSON file including the rules used when running the SQANTI3 rules filter.                     \n                        Default: /home/pabloati/Programs/sqanti3/src/utilities/filter/filter_default.json\n</code></pre> <p></p> <p></p>"},{"location":"Running-SQANTI3-rescue/#machine-learning-rescue-arguments","title":"Machine learning rescue arguments","text":"<p> In addition to the common arguments, the machine learning rescue requires the following specific files:</p> <ul> <li> <p>Pre-trained random forest classifier: using the <code>-r</code> flag, users must provide the <code>randomforest.RData</code> object that was obtained when running the machine learning filter on the long read-defined transcriptome. This classifier will be used to run the ML filter on reference transcriptome isoforms, i.e. obtain an ML probability value for reference rescue targets and evaluate their likelihood to be a true isoform based on orthogonal data supplied to SQANTI3 QC. Note that, to achieve this, SQANTI3 rescue requires the classification file output after running SQANTI3 QC on the reference to be provided via the <code>--refClassif</code> argument.</p> </li> <li> <p>ML probability threshold: minimum probability value that is required in order to consider a transcript to be a true isoform. It should be set using the <code>-j</code> flag (default: 0.7). We recommend setting the same threshold that was used when running SQANTI3 filter.</p> </li> </ul> <p>All in all, these are the arguments accepted by <code>sqanti3_rescue.py ml</code>:</p> <pre><code>usage: sqanti3_rescue.py ml [-h] --filter_class FILTER_CLASS --refGTF REFGTF --refFasta REFFASTA [--rescue_isoforms RESCUE_ISOFORMS] [--rescue_gtf RESCUE_GTF] [-k REFCLASSIF] [-e {all,fsm,none}]\n                            [--mode {automatic,full}] [-o OUTPUT] [-d DIR] [-c CPUS] [-v] [-l {ERROR,WARNING,INFO,DEBUG}] [-r RANDOM_FOREST] [-j THRESHOLD]\n</code></pre> Arguments explanation <pre><code>Rescue for ML-filtered transcriptomes.\n\noptions:\n  -h, --help            show this help message and exit\n\nRequired arguments:\n  --filter_class FILTER_CLASS\n                        SQANTI filter (ML or rules) output classification file.\n  --refGTF REFGTF       Full path to reference transcriptome GTF used when running SQANTI3 QC.\n  --refFasta REFFASTA   Full path to reference genome FASTA used when running SQANTI3 QC.\n\nInput options:\n  --rescue_isoforms RESCUE_ISOFORMS\n                        FASTA file output by SQANTI3 QC (*_corrected.fasta), i.e. the full long read transcriptome.\n  --rescue_gtf RESCUE_GTF\n                        GTF file output by SQANTI3 filter (*.filtered.gtf).\n  -k REFCLASSIF, --refClassif REFCLASSIF\n                        Full path to the classification file obtained when running SQANTI3 QC on the reference transcriptome.                        \n                        Mandatory when running the rescue on full mode\n\nCustomization options:\n  -e {all,fsm,none}, --rescue_mono_exonic {all,fsm,none}\n                        Whether or not to include mono-exonic artifacts in the rescue.                    \n                        Default: all\n  --mode {automatic,full}\n                        If 'automatic' (default), only automatic rescue of FSM artifacts will be performed.                     \n                        If 'full', rescue will include mapping of ISM, NNC and NIC artifacts to find potential replacement isoforms.\n\nOutput options:\n  -o OUTPUT, --output OUTPUT\n                        Prefix for output files.\n  -d DIR, --dir DIR     Directory for output files. Default: Directory where the script was run.\n\nExtra options:\n  -c CPUS, --cpus CPUS  Number of CPUs to use. Default: 4\n  -v, --version         Display program version number.\n  -l {ERROR,WARNING,INFO,DEBUG}, --log_level {ERROR,WARNING,INFO,DEBUG}\n                        Set the logging level INFO\n\nMachine Learning specific options:\n  -r RANDOM_FOREST, --random_forest RANDOM_FOREST\n                        Full path to the randomforest.RData object obtained when running the SQANTI3 ML filter.\n  -j THRESHOLD, --threshold THRESHOLD\n                        Machine learning probability threshold to filter elegible rescue targets (mapping hits).                     \n                        Default: 0.7\n</code></pre> <p></p> <p></p>"},{"location":"Running-SQANTI3-rescue/#rescue-output-files","title":"Rescue output files","text":"<p> The final result of SQANTI3 rescue is a transcriptome GTF file - named <code>prefix_rescued.gtf</code> - including all the transcripts that were classified as isoforms by either the rules or the ML filter (already included in the supplied <code>prefix.filtered.gtf</code> file) and the rescued transcript isoforms that were selected from the reference transcriptome (see rescue strategy section above).</p> <p>Other additional output files that are generated in the rescue process will be explained below.</p> <p></p>"},{"location":"Running-SQANTI3-rescue/#common-rescue-output-files","title":"Common rescue output files","text":"<p> - Automatic rescue result (both <code>--mode</code> options): a single-column file named <code>prefix_automatic_rescued_list.tsv</code> containing the IDs of reference transcripts that were selected during automatic rescue.</p> <ul> <li> <p>Rescue candidate files (for <code>--mode full</code>): Briefly, rescue candidates are a group artifact transcripts from the ISM, NIC and NNC categories (which did not undergo automatic rescue) for which a reference transcript match needs to be found. Two rescue candidate files are generated:</p> </li> <li> <p>A rescue candidate ID list, named <code>prefix_rescue_candidates.tsv</code>.</p> </li> <li> <p>A rescue candidate FASTA file named <code>prefix_rescue_candidates.fasta</code> containing the sequences of rescue candidates for mapping.</p> </li> <li> <p>Rescue target files (for <code>--mode full</code>). As explained above, rescue targets are those reference and long read-defined transcripts for which there is a same-gene rescue candidate counterpart. During the rescue, candidates are mapped to targets using minimap2. Similarly to rescue candidates, two rescue target files are generated:</p> </li> <li> <p>ID list: <code>prefix_rescue_targets.tsv</code>.</p> </li> <li> <p>FASTA file: <code>prefix_rescue_targets.fasta</code>.</p> </li> <li> <p>Mapping results (for <code>--mode full</code>): as a result of mapping with minimap2, two files are generated by SQ3 rescue:</p> </li> <li> <p>Minimap2 SAM file containing the mapping results, named <code>prefix_mapped_rescue.sam</code>.</p> </li> <li>A three-column table in which the mapping results are summarized, named <code>prefix_rescue_mapping_hits.tsv</code>. This table has the following format:</li> </ul> <pre><code>PB.1.3  0   PB.7707.5\nPB.1.3  256 ENST00000557932.5\nPB.1.3  256 ENST00000558784.5\nPB.1.3  256 ENST00000442898.5\nPB.1.3  256 ENST00000692602.1\nPB.1.3  256 ENST00000686495.1\n\n</code></pre> <p>Here, the first column contains the rescue candidate ID, the second column includes the SAM flag indicating the type of alignment and the last column indicates the ID of the rescue target that the candidate was successfully mapped to.</p> <ul> <li>Rescue summary table:</li> </ul> <p>For <code>mode --automatic</code> (default), the <code>prefix_rescue_table.tsv</code> file shows the artifacts considered for automatic rescue, and the reference transcript that they have been replaced with:</p> <ul> <li>Column 1 (<code>artifact</code>): artifact ID. Includes filtered FSM and ISM associated to the same references.</li> <li>Column 2 (<code>rescued_transcript</code>): reference ID for the re-introduced ref. transcript. All filtered FSM and ISM associated to the same reference will be considered as supporting the same rescue event.</li> <li>Column 3 (<code>structural_category</code>): indicates whether <code>artifacts</code> are FSM or ISM.</li> </ul> <p>For  <code>mode --full</code> the <code>prefix_rescue_table.tsv</code> file contains a table in which rescue outcome for all the target-candidate pairs included in the mapping hit table is detailed:</p> <ul> <li>Column 1 (<code>rescue_candidate</code>): rescue candidate ID.</li> <li>Column 2 (<code>sam_flag</code>): SAM flag indicating the type of alignment.</li> <li>Column 3 (<code>mapping_hit</code>): ID of the rescue target that the candidate was successfully mapped to.</li> <li> <p>Column 4 shows the filter result for the mapping hit (or rescue candidate), and may be named <code>hit_POS_MLprob</code> if the <code>ml</code> mode was used, or <code>hit_filter_result</code> if the <code>rules</code> mode was used.</p> <ul> <li>For ML, the <code>hit_POS_MLprob</code> column will contain the probability that the hit is a true isoform provided by the pre-trained random forest classifier.</li> <li>For rules, the <code>hit_filter_result</code> column will read Isoform or Artifact depending on whether or not the hit passed the rules defined in the JSON file.</li> </ul> </li> <li> <p>Column 5 (<code>candidate_structural_category</code>): SQANTI3 category that the rescue candidate (i.e. the artifact that is being considered for rescue) belongs to.</p> </li> <li> <p>Column 6 (<code>rescue_result</code>): final rescue decision. Will be <code>rescued</code> or <code>not_rescued</code> depending on whether or not the isoform was finally included in the rescued transcriptome GTF</p> </li> <li> <p>Column 7 (<code>exclusion_reason</code>): if <code>rescue_result == not_rescued</code>, this column will include a flag explaining why the rescue target was not included in the rescue. On the contrary, if <code>rescue_result == rescued</code>, the column will contain <code>NA</code>. Possible exclusion reasons are:</p> <ul> <li><code>long_read_transcript</code> if the mapping hit is a long read-defined isoform, and is therefore already present in the transcriptome.</li> <li><code>reference_already_present</code> if the mapping hit is a reference transcript that is already represented by an isoform, be it an FSM that passed the filter or a transcript that was obtained during automatic rescue.</li> <li>For ML rescue, <code>ML_probability</code> if the mapping hit did not pass the supplied ML probability threshold. Alternatively, for rules rescue, the flag will read <code>artifact_by_rules</code>, meaning that the mapping hit did not pass the rules specified in the JSON file.</li> </ul> </li> <li> <p>Column 8 (<code>best_match_for_candidate</code>): rescue candidate-level (i.e. transcript-level) summary of the rescue. For each rescue candidate ID, a flag is included summarizing all the decisions that were made regarding all potential rescue targets (mapping hits):</p> <ul> <li><code>reference_transcript</code>: in cases where one or more reference transcripts have been effectively rescued, or where the rescue target was already represented by another transcsript (i.e. the <code>reference_already_present</code> case described above).</li> <li><code>long_read_transcript</code>: whenever no reference transcripts were validated for a given rescue candidate, but at least one good long read-defined match (i.e. passing ML probability/rules) was detected -even if not rescued.</li> <li><code>unknown</code>: this flag is assigned if none of the rescue targets selected for the artifact (i.e. the candidate) pass the ML probability threshold or the specified rules.</li> </ul> </li> <li> <p>Column 9 (<code>best_match_id</code>): for each rescue candidate ID, this column will contain the transcript ID of the candidate's best match, as found by the rescue. This will be defined by the following rules:</p> <ul> <li>Normally, the best match will be the rescue target with the maximum ML filter probability (above the specified threshold) or the one that passed the rules defined in the JSON file, depending on whether the rescue was run in the <code>ml</code> or <code>rules</code> modes.</li> <li>In case of ties (i.e. multiple targets have scored the maximum ML probability or passed the filter rules), the primary alignment obtained during mapping of candidates vs targets will be selected, if present. If none of the ties include the primary alignment, all transcripts that passed the probability/rules criteria will be reported.</li> <li>Finally, in case of <code>best_match_for_candidate == unknown</code>, the best match ID will also be <code>unknown</code>.</li> </ul> </li> </ul> <p>An example of what this table would look like for one rescue candidate and all its assigned mapping hits/rescue targets (in this case for the <code>ml</code> rescue mode) can be viewed here:</p> <pre><code>rescue_candidate    sam_flag    mapping_hit hit_POS_MLprob  candidate_structural_category   rescue_result   exclusion_reason    best_match_for_candidate    best_match_id\nPB.1.3  0   PB.7707.5   0.754   novel_not_in_catalog    not_rescued long_read_transcript    reference_transcript    ENST00000692602.1\nPB.1.3  256 ENST00000557932.5   0.93    novel_not_in_catalog    not_rescued reference_already_present   reference_transcript    ENST00000692602.1\nPB.1.3  256 ENST00000558784.5   0.098   novel_not_in_catalog    not_rescued ML_probability  reference_transcript    ENST00000692602.1\nPB.1.3  256 ENST00000442898.5   0.18    novel_not_in_catalog    not_rescued ML_probability  reference_transcript    ENST00000692602.1\nPB.1.3  256 ENST00000692602.1   0.998   novel_not_in_catalog    not_rescued reference_already_present   reference_transcript    ENST00000692602.1\nPB.1.3  256 ENST00000686495.1   0.066   novel_not_in_catalog    not_rescued ML_probability  reference_transcript    ENST00000692602.1\nPB.1.4  0   PB.7707.5   0.754   novel_not_in_catalog    not_rescued long_read_transcript    reference_transcript    ENST00000692602.1\n\n</code></pre> <ul> <li>Rescue inclusion list (<code>--mode full</code>): a single-column file containing the IDs of all rescued transcripts, named <code>prefix_rescue_inclusion-list.tsv</code>. In this list, both the IDs of rescued transcripts obtained via automatic rescue and via rescue-by-mapping are combined into a single inclusion list. This list is used to generate the final rescued transcriptome GTF, i.e. <code>prefix_rescued.gtf</code>.</li> </ul> <p></p>"},{"location":"Running-SQANTI3-rescue/#rules-specific-output","title":"Rules-specific output","text":"<p> In addition to the common output files, when running <code>--mode full</code>, the rules rescue will create a new folder within the designated output directory to save rules filter output files, i.e. the results of running the rules filer on the reference transcriptome. This folder is named <code>reference_rules_filter</code> in all cases, while all files within it will have <code>reference_</code> as prefix. The <code>reference_RulesFilter_result_classification.txt</code> file will be used by SQANTI3 rescue to get the rules filter result for reference transcripts.</p> <p></p>"},{"location":"Running-SQANTI3-rescue/#machine-learning-specific-output","title":"Machine learning-specific output","text":"<p> In addition to the common output files listed above, when running <code>--mode full</code>, the ML rescue will also output a table including the result obtained after running the pre-trained ML classifier on the reference transcriptome. This file, named <code>prefix_reference_isoform_predict.tsv</code>, will contain reference transcript IDs in the first column and random forest classifier-generated probability values on the second. This probability can be interpreted as the extent to which the transcript is supported by SQANTI3 QC orthogonal data (short-reads, CAGE/polyA peaks, etc.). An example of this output is represented below:</p> <pre><code>isoform POS_MLprob\nDQ459430    0.25\nDQ516784    0.262\nDQ516752    0.27\nDQ668364    0.262\nDQ883670    0.804\nEF011062    0.512\nDQ875385    0.758\n</code></pre>"},{"location":"Running-SQANTI%E2%80%90reads/","title":"Running SQANTI-reads","text":"<p>You can find out more about SQANTI-reads here: Keil N, Monz\u00f3 C, McIntyre L, Conesa A (2025). Quality assessment of long read data in multisample lrRNA-seq experiments with SQANTI-reads. Genome Res. DOI: 10.1101/gr.280021.124</p> <p>SQANTI-reads leverages SQANTI3, a tool for the analysis of the quality of transcript models, to develop a quality control protocol for replicated long-read RNA-seq experiments. The number/distribution of reads, as well as the number/distribution of unique junction chains (transcript splicing patterns), in SQANTI3 structural categories are compiled. Multi-sample visualizations of QC metrics can also be separated by experimental design factors. We introduce new metrics for 1) the identification of potentially under-annotated genes and putative novel transcripts and 2) variation in junction donors and acceptors.</p>"},{"location":"Running-SQANTI%E2%80%90reads/#introduction-to-sqanti-reads","title":"Introduction to SQANTI-reads","text":"<p>SQANTI-reads has two modes of running: fast and simple.  </p>"},{"location":"Running-SQANTI%E2%80%90reads/#sqanti-reads-fast-mode-recommended","title":"SQANTI-reads fast mode (RECOMMENDED).","text":"<p>In the fast mode, SQANTI-reads takes as (minimum) input i) a design CSV file with a column sampleID that includes the names of the samples (as we want them to be represented in the output plots), and a column file_acc with the name of the directory where the output SQANTI3 is stored. And ii) the reference annotation.gtf file.</p> <p>An example design file is:</p> sampleID file_acc wtc11_PBcDNA ENCFF003QZT wtc11_PBCapTrap ENCFF023EXJ wtc11_ONTR2C2 ENCFF063ASB wtc11_ONTdRNA ENCFF104BNW wtc11_cDNA ENCFF105WIJ <p>To run SQANTI-reads in fast mode, you must first, run SQANTI3-QC on all your samples individually (great opportunity for you to parallelize this using your system's slurm, gnu parallel or your favourite parallelization method). Using the parameter <code>--input_dir</code>, you can give sqanti3_reads.py the path to the parent directory where all the SQANTI3-QC output directories are stored.</p> <p>We recommend using fast mode, this ensures you can easily parallelize your work and have more control over mapping parameters. The usual reads pre-processing pipelines for ONT and PacBio to run SQANTI-reads include: - For ONT: Running pychopper to strand the reads, remove primers and polyA tails. - For PacBio: Running lima and refine from IsoSeq pipeline, and <code>bamtools convert -format fastq -in fl.bam</code> to transform PacBio FL bams into fastq files for mapping. - Common next steps: mapping with minimap2, transforming to gtf using spliced_bam2gff and running SQANTI3-QC.</p> <p>Directories with SQANTI3-QC output are named as {file_acc} (e.g. ./ENCFF003QZT/) and SQANTI3-QC output files are named as {sampleID} (e.g. ./ENCFF003QZT/wtc11_PBcDNA_classification.txt)</p> <p>Example run starting after running spliced_bam2gff:</p> <pre><code>python sqanti3_qc.py ENCFF003QZT.gff --annotation hg38.ensGene.gtf --genome hg38.fa --skipORF --min_ref_len 0 --aligner_choice minimap2 -t 8 -d ./ENCFF003QZT -o wtc11_PBcDNA\npython sqanti3_reads.py --design design.csv --annotation hg38.ensGene.gtf\n</code></pre>"},{"location":"Running-SQANTI%E2%80%90reads/#sqanti-reads-minimum-simple-mode","title":"SQANTI-reads (minimum) simple mode.","text":"<p>In the simple mode, SQANTI-reads takes as (minimum) input a design CSV file with a column sampleID that includes the names of the samples (as we want them to be represented in the output), and a column file_acc with the name of the FASTQ or GTF/GFF files. It also requires the reference genome fasta, and reference annotation gtf.</p> <p>When running in simple mode, it will call SQANTI3-QC pipeline sequentially for each sample to: - If FASTQ files were inputted, call SQANTI3-QC and first map using minimap2 (by default, but can be changed to uLTRA), and second transform to GTF for isoform classification. - If GTF files were inputted, it will call SQANTI3-QC directly for isoform classification.  </p> <p>Once the SQANTI3-QC pipeline is run within SQANTI-reads, it will automatically fill two columns in the design CSV file, classification_file and junction_file. These columns will include the names of the files generated for each sampleID. Each of these generated classification and junction files, will be stored within one sub-directory per sample, named as the file_acc. Next, it will calculate all the SQANTI-reads metrics. Finally, it will generate the plots and tables summarizing the metrics results.</p> <p>Where design.csv is:</p> sampleID file_acc wtc11_PBcDNA ENCFF003QZT wtc11_PBCapTrap ENCFF023EXJ wtc11_ONTR2C2 ENCFF063ASB wtc11_ONTdRNA ENCFF104BNW wtc11_cDNA ENCFF105WIJ <p>Example run:</p> <pre><code>python sqanti3_reads.py --design design.csv --annotation hg38.ensGene.gtf --genome hg38.fa\n</code></pre> <p>Fastq files are named {file_acc}*.fastq (e.g. ENCFF003QZT_PB.fastq) and are stored in the current directory.</p>"},{"location":"Running-SQANTI%E2%80%90reads/#getting-ready","title":"Getting ready","text":"<p>Before running SQANTI-reads, you will need to:</p> <p>Activate the SQANTI3 conda environment:</p> <pre><code>(base)-bash-4.1$ conda activate SQANTI3.env\n(SQANTI3.env)-bash-4.1$\n</code></pre>"},{"location":"Running-SQANTI%E2%80%90reads/#arguments-and-parameters-in-sqanti-reads","title":"Arguments and parameters in SQANTI-reads","text":"<p>The SQANTI-reads script accepts the following arguments:</p> <pre><code>usage: sqanti3_reads.py [-h] [--genome GENOME] --annotation ANNOTATION -de INDESIGN [-i INPUT_DIR] [-f INFACTOR]\n                       [-p PREFIX] [-d DIR] [--min_ref_len MIN_REF_LEN] [--force_id_ignore]\n                       [--aligner_choice {minimap2,uLTRA}] [-t CPUS] [-n CHUNKS] [-s SITES] [-ge ANNOTEXP]\n                       [-je JXNEXP] [-pc PERCCOV] [-pj PERCMAXJXN] [-fl FACTORLVL] [--all_tables] [--report {pdf,html,both}] [--pca_tables]\n                       [--skip_hash] [--verbose] [-v]\n\nStructural and Quality Annotation of Novel Transcript Isoforms\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --genome GENOME       Reference genome (Fasta format).\n  --annotation ANNOTATION\n                        Reference annotation file (GTF format).\n  -de INDESIGN, --design INDESIGN\n                        Path to design file, must have sampleID and file_acc column.\n  -i INPUT_DIR, --input_dir INPUT_DIR\n                        Path to directory where fastq/GTF files are stored. Or path to parent directory with\n                        children directories of SQANTI3 runs. Default: Directory where the script was run.\n  -f INFACTOR, --factor INFACTOR\n                        This is the column name that plots are to be faceted by. Default: None\n  -p PREFIX, --prefix PREFIX\n                        SQANTI-reads output filename prefix. Default: sqantiReads\n  -d DIR, --dir DIR     Directory for output sqanti_reads files. Default: Directory where the script was run.\n  --min_ref_len MIN_REF_LEN\n                        Minimum reference transcript length. Default: 0 bp\n  --force_id_ignore     Allow the usage of transcript IDs non related with PacBio's nomenclature (PB.X.Y)\n  --aligner_choice {minimap2,uLTRA}\n                        Default: minimap2\n  -t CPUS, --cpus CPUS  Number of threads used during alignment by aligners. Default: 10\n  -n CHUNKS, --chunks CHUNKS\n                        Number of chunks to split SQANTI3 analysis in for speed up. Default: 1\n  -s SITES, --sites SITES\n                        Set of splice sites to be considered as canonical (comma-separated list of splice sites).\n                        Default: GTAG,GCAG,ATAC.\n  -ge ANNOTEXP, --gene_expression ANNOTEXP\n                        Expression cut off level for determining underannotated genes. Default = 100\n  -je JXNEXP, --jxn_expression JXNEXP\n                        Coverage threshold for detected reference donors and acceptor. Default = 10\n  -pc PERCCOV, --perc_coverage PERCCOV\n                        Percent gene coverage of UJC for determining well-covered unannotated transcripts.\n                        Default = 20\n  -pj PERCMAXJXN, --perc_junctions PERCMAXJXN\n                        Percent of the max junctions in gene for determining near full-length putative novel\n                        transcripts. Default = 80\n  -fl FACTORLVL, --factor_level FACTORLVL\n                        Factor level to evaluate for underannotation\n  --all_tables          Export all output tables. Default tables are gene counts, ujc counts, length_summary, cv\n                        and and underannotated gene tables\n  --pca_tables          Export table for making PCA plots  \n  --skip_hash           Skip the hashing step\n  --report {pdf,html,both}\n                        Default: pdf\n  --verbose             If verbose is run, it will print all steps, by default it is FALSE\n  -v, --version         Display program version number.\n</code></pre>"},{"location":"Running-SQANTI%E2%80%90reads/#sqanti-reads-output","title":"SQANTI-reads output","text":"<p>The sqanti-reads output is written to the path specified in <code>--dir</code> or <code>-d</code> argument, also appending the prefix provided via the <code>--prefix</code> or -p argument.</p> <p>The following output files are generated after running it:</p>"},{"location":"Running-SQANTI%E2%80%90reads/#modified-input-files","title":"Modified input files","text":"<p>New reads_classification.txt files will be generated, including all columns from the original files plus two additional columns: - jxn_string: includes the unique junction chain string as <code>chromosome_strand_junction1_junction2_junctionN</code>. Monoexons are coded as <code>chromosome_strand_monoexon_readID</code>. - jxnHash: includes the hashing of the jxn_string for easier work in next steps.</p> <p>The design file will be modified to include all initial columns (e.g. sampleID, file_acc, platform, age, sex) and two additional columns:</p> <ul> <li>classification_file: will include the full paths to the reads_classification.txt files (output of SQANTI-reads).</li> <li>junction_file: will include the full paths to the junctions.txt files (output of SQANTI3).</li> </ul>"},{"location":"Running-SQANTI%E2%80%90reads/#results-default-csv-files","title":"Results default .csv files","text":"<ul> <li>sqantiReads_cv.csv: Provides metrics on the coefficient of variance of reference junctions, per sample.</li> <li>sqantiReads_gene_counts.csv: Provides the number of reads in each structural category, per gene, per sample.</li> <li>sqantiReads_length_summary.csv: Provides the number and percentage of reads in length categories per sample.</li> <li>sqantiReads_ujc_counts.csv: Provides a list of junction strings in each sample and the number of reads in each sample associated with each junction string.</li> <li>sqantiReads_gene_classification.csv: For genes with coverage meeting a user defined threshold (-ge), provides the annotation category of each gene.</li> <li>sqantiReads_putative_novel_transcripts.csv: Provides metrics on NIC and NNC UJCs and flags putative novel transcripts.</li> </ul>"},{"location":"Running-SQANTI%E2%80%90reads/#results-optional-csv-files","title":"Results optional .csv files","text":"<ul> <li>sqantiReads_cv_acc/don_counts.csv: Provides the number of detected annotated donors and acceptors in each junction variation category.</li> <li>sqantiReads_cv_acc/don_counts.csv: Provides the number of detected annotated donors and acceptors in each junction variation category.</li> <li>sqantiReads_FSM/ISM/NIC_NNC_counts.csv: Provides the number of reads in each subcategory for FSMs, ISMs, NICs and NNCs.</li> <li>sqantiReads_err_counts.csv: Provides the number and percentage of reads with. evidence of intrapriming, RT-switching and non-canonical junctions per samples.</li> <li>sqantiReads_pca_loadings.csv: Gives loadings of PC1 and PC2 for the PCA analaysis.</li> <li>sqantiReads_pca_variance.csv: Gives the proportion variance explained by each PC.</li> </ul>"},{"location":"Running-SQANTI%E2%80%90reads/#results-plots","title":"Results plots","text":"<ul> <li>sqantiReads_plots.pdf: Pdf file with one output plot visualizing QC metrics per page.</li> <li>sqantiReads_annotation_plots.pdf: Pdf file with one output plot visualizing underannotation metrics per page.</li> </ul>"},{"location":"Running-SQANTI%E2%80%90reads/#running-example-sqanti-reads","title":"Running example SQANTI-reads","text":"<p>There is an example dataset with three small samples on the SQANTI3/example/sqanti_reads_test/ directory. If you run it from the main SQANTI3 directory, you can run it in simple mode with the following command:</p> <pre><code>python sqanti3_reads.py --design ./example/sqanti_reads_test/sqR_design_file.csv -i ./example/sqanti_reads_test/ -p SQ_R --annotation ./example/gencode.v38.basic_chr22.gtf --genome ./example/GRCh38.p13_chr22.fasta --dir ./example/sqanti_reads_test/ --report both\n</code></pre>"},{"location":"Running-SQANTI%E2%80%90reads/#citing-sqanti-reads","title":"Citing SQANTI-reads","text":"<p>If you are using SQANTI-reads, please cite: Keil N, Monz\u00f3 C, McIntyre L, Conesa A (2025). Quality assessment of long read data in multisample lrRNA-seq experiments with SQANTI-reads. Genome Research, 35 (4), 987. DOI: 10.1101/gr.280021.124</p> <p>SQANTI-reads is based, and uses SQANTI3, please also cite: Pardo-Palacios FJ, Arzalluz-Luque A, Kondratova L, Salguero P, Mestre-Tom\u00e1s J, Amor\u00edn R, Estevan-Mori\u00f3 E, Liu T, Nanni A, McIntyre L, Tseng E, Conesa A (2024). SQANTI3: curation of long-read transcriptomes for accurate identification of known and novel isoforms. Nature Methods, 21, 793-797. DOI: 10.1038/s41592-024-02229-2</p>"},{"location":"SQANTI3-isoform-classification%3A-categories-and-subcategories/","title":"Isoform classification - categories and subcategories","text":""},{"location":"SQANTI3-isoform-classification%3A-categories-and-subcategories/#isoform-categories","title":"Isoform categories","text":"<p>SQANTI3 classifies each isoform by finding the best matching reference transcript, in the following order:</p> <ul> <li> <p>FSM (Full Splice Match): meaning the reference and query isoform have the same number of exons and each internal junction agree. The exact 5' start and 3' end can differ by any amount.</p> </li> <li> <p>ISM (Incomplete Splice Match): the query isoform has fewer 5' exons than the reference, but each internal junction agree. The exact 5' start and 3' end can differ by any amount.</p> </li> <li> <p>NIC (Novel In Catalog): the query isoform does not have a FSM or ISM match, but is using a combination of known donor/acceptor sites.</p> </li> <li> <p>NNC (Novel Not in Catalog): the query isoform does not have a FSM or ISM match, and has at least one donor or acceptor site that is not annotated.</p> </li> <li> <p>Antisense: the query isoform does not have overlap a same-strand reference gene but is anti-sense to an annotated gene. </p> </li> <li> <p>Genic Intron: the query isoform is completely contained within an annotated intron.</p> </li> <li> <p>Genic Genomic: the query isoform overlaps with introns and exons.</p> </li> <li> <p>Intergenic: the query isoform is in the intergenic region.</p> </li> </ul> <p></p>"},{"location":"SQANTI3-isoform-classification%3A-categories-and-subcategories/#isoform-subcategories","title":"Isoform subcategories","text":"<p>Some of the SQ3 categories are further divided into subcategories (specified in the <code>subcategory</code> field in SQANTI3  classification output). These will be explained in the sections below.</p>"},{"location":"SQANTI3-isoform-classification%3A-categories-and-subcategories/#fsm-subcategories","title":"FSM subcategories","text":""},{"location":"SQANTI3-isoform-classification%3A-categories-and-subcategories/#ism-subcategories","title":"ISM subcategories","text":""},{"location":"SQANTI3-isoform-classification%3A-categories-and-subcategories/#novel-isoform-subcategories-nic-and-nnc","title":"Novel isoform subcategories (NIC and NNC)","text":"<p>Novel isoforms are subtyped based on whether they use a combination of known junctions (junctions are pairs of donor-acceptor sites), a combination of known splice sites (the individual donor and acceptor sites are known, but at least combination is novel), or at least one splice site (donor or acceptor) is novel.</p> <p></p>"},{"location":"SQANTI3-memory-requeriments-and-paralellization/","title":"Memory requirements and parallelization","text":"<p>SQANTI3 can be run in any machine that can install python, conda and the necessary dependencies. However, the time complexity and memory requirements can be very different depending on the dataset analyzed.</p> <p>To test the evolution of time and memory complexity as the dataset grows, we used one medium size transcriptome with 156k transcripts and a big transciptome with 3.56 million transcripts.</p>"},{"location":"SQANTI3-memory-requeriments-and-paralellization/#time-complexity-no-parallelization","title":"Time complexity (no parallelization)","text":"<p>The necessary time to run SQANTI3 (QC, filter or rescue) increases linearly with the number of transcripts given in the input file (either .gtf or fastq). Therefore, SQANTI3 QC has a time complexity that differs in different stages:</p> <ul> <li>As the number of transcripts in the gtf or fastq input file increases, the time needed increases linearly (time complexity is O(n)), </li> <li>The longest step is usually the mapping of the short reads, which can take most of computation time if the transcriptome is small in comparison to the short reads files. To speed up the process, we recommend mapping the reads beforehand, and giving the mapped bam as input.</li> </ul>"},{"location":"SQANTI3-memory-requeriments-and-paralellization/#memory-complexity-no-parallelization","title":"Memory complexity (no parallelization)","text":"<p>SQANTI3 can be used in most desktops and laptops for small and medium transcriptomes: For example, a 156k transcripts require about 5.8 GB of RAM, therefore it can be run on a desktop or laptop with 8 GB of RAM. Regardless, it may take a considerable amount of time, as this example transcriptome took 28 minutes to run in an HPC environment.</p> <p>In any case, some of the parameters used to run SQANTI3 require and increase in the amount of RAM, such as providing a short reads to map.</p>"},{"location":"SQANTI3-memory-requeriments-and-paralellization/#paralellization-requirements","title":"Paralellization requirements","text":"<p>Using the -n option in chunks allows SQANTI3 QC to work in parallel and accelerate the analysis. However, by doing so, memory requirements increase in a considerable manner.</p> <p>For example, using the 156k transcripts dataset for testing parallelization process in a HPC, the memory cost is linear (memory complexity is O(n), n being how many chunks were used), while real time needed to process the dataset was reduced up to a 25% of the time needed to process without parallelization.</p> <ul> <li>This dataset took 1678 seconds (about 28 minutes) to process without parallelization, and required 5.87 GB of RAM.</li> <li>Using -n 2 reduced the time to 624 seconds (about 10 minutes), and increased memory to 8.12 GB. </li> <li>Using -n 7 further reduced the time to 525s (about 8 and half minutes).</li> <li>Using -n 14 (the optimal number for this dataset), took 322 seconds and required 48 GB of RAM.</li> <li>From this moment onwards, adding more chunks improves the run time marginally, while RAM usage still grows linearly. In cases where memory is not a constraint and time is limited, it may be useful to use as many chunks as your memory can hold.</li> </ul> <p>Time is greatly reduced just by using parallelization.</p> <p></p> <p>However, memory increase must be taken into account if memory might be a limitation in analysis. The linear increase may be a problem in some use cases.</p> <p></p> <p>For the big (3.56 million transcripts) dataset, time and memory greatly increased:</p> <ul> <li>This dataset took ~22 hours to be processed without parallelization, requiring 23.89 GB of RAM. With this RAM usage, transcriptomes as big as this one might not be able to be processed in desktop computers or laptops.</li> <li>Using -n 4 or -n 5, reduced the run time to approximately 10 hours, but the memory increased up to 100 GB of RAM.</li> <li>Using -n 10 required 200 GB of RAM.</li> </ul>"},{"location":"SQANTI3-memory-requeriments-and-paralellization/#outliers","title":"Outliers","text":"<p>When testing the use of different number of chunks, some outliers were found in the processing time of the dataset. In the medium dataset, running SQANTI3 QC using 5, 6 or 15 chunks took longer than using 4 or 14 chunks, while memory usage increased. These results were consistent across several repetitions. While the general trend does not change (a higher number of chunks reduces the overall time required, but increases memory usage in a linear manner), this suggests that some trial-and-error might be needed to find the optimal number of chunks for each dataset.</p>"},{"location":"SQANTI3-memory-requeriments-and-paralellization/#conclusions-and-recommendations","title":"Conclusions and recommendations","text":"<p>Increasing the number of parallelization chunks can speed SQANTI3 QC to take as low as 25% of the non-parallelized time. However, the linear increase in memory requirements implies that this option should be used with care in situations in which memory might be a constraint. If SQANTI3 must be used in a desktop, laptop or server with limited specifications, parallelization should be planned in small datasets, which may be fast enough even without parallelization, or medium-size, with a reduced number of cores. Medium or big datasets should be analyzed with 32 GB of RAM or more, but parallelization can be risky, and out of memory errors may be common.</p> <p>Big datasets, such as the one mentioned above, are recommended to be executed in HPC systems if available, as RAM requirements and time needed to analyze them increase considerably. Using 5 or more cores would require at least 100 GB of RAM.</p> <p>Regardless of the situation, similar transcriptomes (in number of transcripts) should have a similar performance in time and memory when analyzed with the same parameters. Therefore, once you are confident the transcriptome is analyzed with a good, stable number of cores, you can consider that other similar datasets should have similar requirements. This can be used to estimate how much RAM is needed and how many chunks should be used.</p>"},{"location":"Sqanti3-wrapper-script/","title":"Sqanti3 wrapper script","text":"<p>Sqanti3 wrapper is a tool written in bash to run a QC, filter, rescue pipeline of SQANTI3 from an automated script with a reusable config file</p> <p>To execute Sqanti3_wrapper, the conf file must be provided with all the paths and parameters needed to execute either QC, filter, rescue or a combination of them. Most of the parameters have a default argument: In most cases, because they point to a file that is, or will be, automatically generated by a previous step; and by default, it will execute the example provided in the repository.</p> <p>The arguments are classified into: - General arguments for two or more steps of sqanti - Flow control, to skip steps at will - Sqanti QC parameters - Sqanti filter parameters - Sqanti rescue parameters - Custom values for particular executions. They are usually not needed to change, but present for particular executions (such as using docker or singularity).</p> <ul> <li>General arguments</li> </ul> <p>Here you can specify the references used in the analysis, the number of cores to use, and the main parameters for the rules and ml methods of filter and rescue. By default, these values are common to the different steps in which they are available</p> <pre><code>reference_gtf=\"example/gencode.v38.basic_chr22.gtf\"\nreference_fasta=\"example/GRCh38.p13_chr22.fasta\"\ncpus=\"4\"\njson_for_rules=\"utilities/filter/filter_default.json\" # json file with rules for filter and rescue rules\nthreshold=\"0.7\" \n</code></pre> <ul> <li>Flow control</li> </ul> <p>QC, filter and rescue can be skiped if they have already been computed, or if not interested in filter and/or rescue, by changing the corresponding varible to true. If not skiped, filter and rescue can be used in mode rules, ml or both</p> <pre><code>skip_qc=\"false\" #true to skip the QC\nskip_filter=\"true\" # true to skip the filter\nfilter_mode=\"both\" # rules, ml or both\nskip_rescue=\"false\" # true to skip the rescue\nrescue_mode=\"both\" # rules, ml or both\n</code></pre> <ul> <li>Sqanti QC:</li> </ul> <p>Sqanti3 has many parameters, but only 3 of them are mandatory: input GTF, reference GTF and reference fasta. The references are defined in the general parameters section, so only the former on is present in this section. All other parameters are optional, but by default they are targeted to the example available, because they are the most common ones. Others have a default option in the script, or different posibilities to  be used. For a detailed infography of the different parameters, how they affect the pipeline, and how to use them effectively, please check the SQANTI3 QC running tutorial or print the help with <code>sqanti3_qc.py -h</code></p> <pre><code>QC_input=\"example/UHR_chr22.gtf\" # Input data\nQC_output_prefix=\"UHR_chr22\"\nQC_destination_folder=\"/tmp/sqanti3_wrapper/QC/\"\n\nQC_min_ref_length=\"\" # minimum reference transcript length. Default 0 bp\nQC_force_id_ignore=\"\" \nQC_cage_peak_bed_file=\"data/ref_TSS_annotation/human.refTSS_v3.1.hg38.bed\"\nQC_aligner_choice=\"\" # minimap2, deSALT, gmap or uLTRA\nQC_polyA_motif_list=\"data/polyA_motifs/mouse_and_human.polyA_motif.txt\"\nQC_polyA_peak=\"\"\nQC_phylobed=\"\"\nQC_skipORF=\"true\"\nQC_is_fusion=\"false\"\nQC_orf_input=\"\"\nQC_is_fastq=\"false\" # Requiered to be true if QC_input is a fastq file.\nQC_expression_matrix=\"\"\nQC_gmap_index=\"\"\nQC_chunks=1 # (int) chunks &gt; 1 activates parallelization\nQC_coverage=\"\" # Junctions coverage file\nQC_sites=\"\"\nQC_window=\"\"\nQC_genename=\"\" # Column name from GTF to define gene names\nQC_full_length_pacbio_abundance_tsv=\"example/UHR_abundance.tsv\"\nQC_saturation=\"true\"\nQC_report_file=\"both\" # pdf, html or both\nQC_isoAnnotLite=\"\"\nQC_gff3=\"\"\nQC_short_reads_fofn=\"example/UHR_chr22_short_reads.fofn\"\nQC_SR_bam=\"\"\nQC_isoform_hits=\"\"\nQC_ratio_TSS_metric=\"\" # Which metric should be reported in the ratio_TSS column\n</code></pre>"},{"location":"Sqanti3-wrapper-script/#sqanti3-filter","title":"SQANTI3 filter","text":"<p>SQANTI3 filter parameters are classified in 3 categories: common arguments, rules specific arguments, and ml specific arguments. For the general parameters, the only mandatory argument is the input classification file. The default paths allow to execute the whole pipeline using the generated files in the QC step, but you can change it at will if you consider so. For a detailed infogram on how these parameters affect the pipeline, please check the SQANTI3 filter running tutorial</p> <pre><code># Common elements for filter rules and ml\nfilter_input_classification=\"${QC_destination_folder}/${QC_output_prefix}_classification.txt\" \n\nfilter_skip_report=\"false\" # true to skip the report\nfilter_corrected_gtf=\"${QC_destination_folder}/${QC_output_prefix}_corrected.gtf\"\nfilter_isoforms=\"GMST/GMST_tmp.faa\"\nfilter_isoannotgff3=\"example/SQANTI3_QC_output/UHR_chr22.gff3\"\nfilter_sam=\"\"\nfilter_faa=\"${QC_destination_folder}/${QC_output_prefix}_corrected.faa\"\nfilter_monoexonic=\"true\"\nfilter_skip_report=\"\"\n</code></pre> <p>SQANTI3 filter rules only need 2 extra optional arguments: Output folder and prefix for the generated files. If not present, the default ones may be used and may overwrite some files. They are strongly recommended</p> <pre><code>filter_rules_ouput_folder=\"/tmp/sqanti3_wrapper/sqanti3_filter_rules\"\nfilter_rules_prefix=\"${QC_output_prefix}\"\n</code></pre> <p>Sqanti3 filter ml provides a few more parameters for tunning its execution, beyond the saving folder and preffix: </p> <pre><code>filter_ml_ouput_folder=\"/tmp/sqanti3_wrapper/sqanti3_filter_ml\"\nfilter_ml_prefix=\"${QC_output_prefix}\"\n\nfilter_ml_percent_training=\"0.8\"\nfilter_ml_TP=\"\" # Path to the file that contains TP. If empty, will be calculated\nfilter_ml_TN=\"\" # Path to the file that contains TN. If empty, will be calculated\nfilter_ml_threshold=${threshold}\nfilter_ml_remove_columns=\"\"\nfilter_ml_intermediate_files=\"\"\nfilter_ml_max_class_size=\"\"\nfilter_ml_intrapriming=\"\"\n</code></pre>"},{"location":"Sqanti3-wrapper-script/#sqanti3-rescue","title":"SQANTI3 rescue","text":"<p>Rescue parameters are fully divided into rules and ml, as each used the output of their corresponding filter method.</p> <p>Rescue rules parameters include some parameters already used by QC and filter. For a complete infography of Rescue's parameters, please check or ask the script for help with </p> <pre><code>rescue_rules_output_prefix=\"${QC_output_prefix}\"\nrescue_rules_output_folder=\"/tmp/sqanti3_wrapper/sqanti3_rescue_rules\"\n\nrescue_rules_filtered_classification=\"${filter_rules_ouput_folder}/${filter_rules_prefix}_RulesFilter_result_classification.txt\" # Output classification from filter step\nrescue_rules_reference_classification=\"${QC_destination_folder}/${QC_output_prefix}_classification.txt\" # The output classification from QC step\nrescue_rules_isoforms=\"${QC_destination_folder}/${QC_output_prefix}_corrected.fasta\" # Corrected isoforms from QC step\nrescue_rules_gtf=\"${filter_rules_ouput_folder}/${filter_rules_prefix}.filtered.gtf\" # Filtered GTF from filter step\nrescue_rules_monoexons=\"all\" # Keep monoexons\nrescue_rules_mode=\"full\"\n</code></pre> <p>Conviniently, rescue ml also needs files generated by QC and Filter. The only extra parameter needed (optional) is the randomforest.Rdata generated by filter ml</p> <pre><code>rescue_ml_output_prefix=\"${QC_output_prefix}\"\nrescue_ml_output_folder=\"/tmp/sqanti3_wrapper/sqanti3_rescue_ml\"\n\nrescue_ml_filtered_classification=\"${filter_ml_ouput_folder}/${filter_ml_prefix}_MLresult_classification.txt\"\nrescue_ml_reference_classification=\"${QC_destination_folder}/${QC_output_prefix}_classification.txt\"\nrescue_ml_isoforms=\"${QC_destination_folder}/${QC_output_prefix}_corrected.fasta\"\nrescue_ml_gtf=\"${filter_ml_ouput_folder}/${filter_ml_prefix}.filtered.gtf\"\nrescue_ml_monoexons=\"all\"\nrescue_ml_mode=\"full\"\nrescue_ml_randomforest_rdata=\"${filter_ml_ouput_folder}/randomforest.RData\"\n</code></pre>"},{"location":"Sqanti3-wrapper-script/#custom-values-for-particular-executions-warning-zone","title":"Custom values for particular executions (Warning zone)","text":"<p>These values have been adjusted to allow execution of the whole pipeline and sharing references and common elements between the different steps, and specify the sqanti3 version you want to use. </p> <p>Select the sqanti you prefer. If you wish it, you can use the docker image (or equivalent singularity image) by changing the python3 statement to a docker run command.</p> <pre><code>sqanti3_qc=\"python3 sqanti3_qc.py\"\nsqanti3_filter=\"python3 sqanti3_filter.py\"\nsqanti3_rescue=\"python3 sqanti3_rescue.py\"\n``\n\nIn case you need or want to execute QC, filter or rescue with different references or files, which is not recommended to keep consistency of the execution, you can change these values. Creating a new config is recommended for this cases instead of customizing these values.\n\n</code></pre> <p>QC_reference_gtf=${reference_gtf} QC_reference_fasta=${reference_fasta} QC_cpus=${cpus}</p> <p>filter_rules_json_file=${json_for_rules}</p> <p>rescue_rules_reference_genome=${reference_fasta} rescue_rules_reference_gtf=${reference_gtf} rescue_rules_json_file=\"${json_for_rules}\"</p> <p>rescue_ml_reference_genome=${reference_fasta} rescue_ml_reference_gtf=${reference_gtf} rescue_ml_threshold=${threshold} ```</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/","title":"Video tutorial","text":"<ul> <li>Watch Tutorial Video on YouTube</li> </ul>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#step-by-step-tutorial","title":"Step-by-Step tutorial","text":"<p>The document is structured to guide users through various aspects of the SQANTI3 tool. 1.  SQANTI3 Installation: This section will guide users on how to install the SQANTI3 tool. It may include prerequisites, dependencies, and step-by-step instructions for a successful installation. 2.  Example Dataset Overview: Before diving into the execution of SQANTI3, users will be introduced to a sample dataset. This dataset includes directories and files that encompass the output from various phases of the SQANTI3 pipeline and the necessary input files to operate the software. Organized under directories and files, users will find outputs from machine learning filters, quality control, and rules-based filtering processes. In addition to the genomic and annotation files for chromosome 22, there are paired-end sequencing read files for two replicates of the Universal Human Reference (UHR) sample and scripts demonstrating how to run different SQANTI3 modules on the provided data. This comprehensive example dataset ensures users have a foundational understanding of the expected data structure and the processes involved in SQANTI3 operations. 3.  Executing and Understanding SQANTI3 QC: Here, users will learn how to run the quality control (QC) component of SQANTI3 which focuses on characterizing transcriptomes generated from lrRNA-Seq data, comparing them to reference annotations, and leveraging various datasets including short-read sequencing, CAGE, and Quant-Seq for a comprehensive evaluation. The guide will delve into the details of FSM and ISM subcategories, the integration of TSS and TTS evidence, and the internal handling of short-read data using tools like STAR and Kallisto. 4.  Executing and Understanding SQANTI3 Filter: This segment introduces the filtering capabilities of SQANTI3. Users will be guided on how to utilize both the machine learning-based and rules-based methods to efficiently differentiate between genuine isoforms and potential artifacts, ensuring a high-quality transcriptome tailored to their research needs. 5.  Executing and Understanding SQANTI3 Rescue: This final section will focus on the 'rescue' functionality of SQANTI3. Users will learn the process of executing this feature and, just as importantly, understand the results and the rationale behind 'rescuing'. The SQANTI3 rescue algorithm aims to retrieve potentially discarded transcripts during long-read data processing by identifying appropriate reference transcripts, ensuring they meet quality criteria and are non-redundant, and then incorporating them into the final transcriptome.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#table-of-contents","title":"Table of Contents","text":"<ul> <li>1. SQANTI3 Installation</li> <li>2. Example Dataset Overview</li> <li>3. Executing and Understanding SQANTI3 QC</li> <li>4. Executing and Understanding SQANTI3 Filter</li> <li>5. Executing and Understanding SQANTI3 Rescue</li> </ul>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#1-installation","title":"1. Installation","text":""},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#11-dependencies","title":"1.1 Dependencies","text":"<ul> <li>General: Perl, Minimap2, Python (3.7), R (&gt;= 3.4.0), kallisto, samtools, STAR, uLTRA, deSALT, pip</li> <li>Python Libraries: bx-python, BioPython, BCBioGFF, cython, NumPy, pysam, pybedtools, psutil, pandas, scipy</li> <li>R Libraries: R packages for <code>sqanti3_qc.py</code> and <code>sqanti3_filter.py</code> (installed with conda environment)</li> </ul>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#12-installation","title":"1.2 Installation","text":"<p>1.2.1. Anaconda: Install/update Anaconda. Add to PATH and update if needed:</p> <pre><code>export PATH=$HOME/anacondaPy37/bin:$PATH\nconda -V\nconda update conda\n</code></pre> <p>1.2.2 SQANTI3: Download SQANTI3 v5.4 and extract:</p> <pre><code>wget https://github.com/ConesaLab/SQANTI3/archive/refs/tags/v5.4.tar.gz\ntar -xvf v5.4.tar.gz\ncd SQANTI3-5.4\n</code></pre> <p>1.2.3 Conda Environment: Create and activate environment:</p> <pre><code>conda env create -f SQANTI3.conda_env.yml\nsource activate sqanti3\n</code></pre>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#2-example-dataset-overview","title":"2. Example Dataset Overview","text":"<p>This section provides a brief overview of the example dataset to be utilized throughout this folder. The dataset consists of various files and directories that represent the output from different stages of the SQANTI3 pipeline. The requisite input files for running SQANTI3 are stored within this directory.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#21-output-directories","title":"2.1 Output directories","text":"<ul> <li>SQANTI3_QC_output: Contains output files generated by the SQANTI3 Quality Control (QC) process.</li> <li>ml_filter_output: This directory contains output files from the machine learning filter process in SQANTI3.</li> <li>rules_filter_output: Houses output files from the rules-based filtering process in SQANTI3.</li> <li>rescue_automatic: This directory contains the output files generated from running SQANTI3 rescue in automatic mode.</li> <li>rescue_rules: In this directory, rescue has been run in full mode using the results from the rules filter.</li> <li>rescue_ml: This directory contains the output files generated from running SQANTI3 rescue in machine learning mode. It used the same random forest model that was generated during the machine learning filter process.</li> </ul>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#22-input-files","title":"2.2 Input files","text":"<ul> <li> <p>Genome and Annotation Files: They are stored in the reference directory.</p> <ul> <li><code>GRCh38.p13_chr22.fasta</code>: A FASTA file containing the sequence of chromosome 22 from the GRCh38.p13 version of the human genome.</li> <li><code>GRCh38.p13_chr22.fasta.fai</code>: Index file for the FASTA file, facilitating quick access to different regions within the file.</li> <li><code>Homo_sapiens_GRCh38_Ensembl_86.chr22.gff3</code>: A GFF3 file containing an annotation for chromosome 22 from the Ensembl 86 release of the human genome.</li> <li><code>gencode.v38.basic_chr22.gtf</code>: A GTF file containing GENCODE basic gene annotation for chromosome 22 from the GENCODE v38 release.</li> </ul> </li> <li> <p>Sample Data:</p> <ul> <li><code>UHR_chr22.gtf</code>: A GTF file containing transcript annotations for the UHR sample, focused on chromosome 22.</li> <li><code>UHR_abundance.tsv</code>: A tab-separated file containing transcript abundance estimates for the UHR sample.</li> <li><code>UHR_chr22_short_reads.fofn</code>: A file of file names (FOFN) listing short-read data files related to the UHR sample on chromosome 22.<ul> <li><code>UHR_Rep1_chr22.R1.fastq.gz</code> and <code>UHR_Rep1_chr22.R2.fastq.gz</code>: Paired-end sequencing read files for replicate 1 of a Universal Human Reference (UHR) sample, focused on chromosome 22.</li> <li><code>UHR_Rep2_chr22.R1.fastq.gz</code> and <code>UHR_Rep2_chr22.R2.fastq.gz</code>: Paired-end sequencing read files for replicate 2 of a UHR sample, focused on chromosome 22.</li> </ul> </li> </ul> </li> </ul>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#23-example-scripts-and-config-files","title":"2.3 Example scripts and config files:","text":"<ul> <li> <p>Scripts:</p> <ul> <li><code>run_SQANTI3_QC.sh</code>: A shell script demonstrating how to run the SQANTI3 Quality Control (QC) process on the example data.</li> <li><code>run_SQANTI3_MLfilter.sh</code>: A shell script demonstrating how to run the SQANTI3 machine learning filter.</li> <li><code>run_SQANTI3_rules_filter.sh</code>: A shell script demonstrating how to run the SQANTI3 rules-based filtering process on the example data.</li> </ul> </li> <li> <p>Config files: They can be found under <code>examples/config_files</code> directory, in YAML format, to be used with the wrapper.</p> </li> </ul>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#3-executing-and-understanding-sqanti3-qc-video-for-this-part","title":"3. Executing and Understanding SQANTI3 QC  (Video for this part)","text":"<p>SQANTI3 is the updated iteration of the SQANTI tool designed for quality control and characterization of transcriptomes built from lrRNA-Seq data. Central to SQANTI3 is its Quality Control (QC) module, which evaluates the de novo transcriptome against a reference annotation and outputs a classification file. This classification not only delves deep into transcript variations like Full Splice Matches (FSM) and Incomplete Splice Matches (ISM) but also introduces new subcategories for them. Additionally, SQANTI3 QC integrates evidence from both short and long-read data, even accepting orthogonal data types like CAGE and Quant-Seq, to support and validate transcript start and end sites. The software has also been enhanced to handle short-read data internally, incorporating tools like STAR and Kallisto for mapping and quantification.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#31-running-sqanti3-qc-with-example-command","title":"3.1 Running SQANTI3 QC with example command:","text":"<p>The provided command runs the <code>sqanti3_qc.py</code> script which is designed for structural and quality annotation of novel transcript isoforms.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#311-example-script","title":"3.1.1 Example script","text":"<pre><code>python sqanti3_qc.py --isoforms example/UHR_chr22.gtf \\\n                     --refGTF example/gencode.v38.basic_chr22.gtf \\\n                     --refFasta example/GRCh38.p13_chr22.fasta    \\\n                     --CAGE_peak data/ref_TSS_annotation/human.refTSS_v3.1.hg38.bed    \\\n                     --polyA_motif_list data/polyA_motifs/mouse_and_human.polyA_motif.txt    \\\n                     -o UHR_chr22 -d example/SQANTI3_output -fl example/UHR_abundance.tsv    \\\n                     --short_reads example/UHR_chr22_short_reads.fofn --cpus 4 --report both\n</code></pre>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#312-required-arguments","title":"3.1.2 Required Arguments:","text":"<ol> <li><code>--isoforms example/UHR_chr22.gtf</code>:<ul> <li>Input isoforms file in GTF format. This could be given in FASTA format as well.</li> </ul> </li> <li><code>--refGTF example/gencode.v38.basic_chr22.gtf</code>:<ul> <li>Reference annotation file in GTF format.</li> </ul> </li> <li><code>--refFasta example/GRCh38.p13_chr22.fasta</code>:<ul> <li>Reference genome file in FASTA format.</li> </ul> </li> </ol>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#313-optional-arguments","title":"3.1.3 Optional Arguments:","text":"<ul> <li><code>--CAGE_peak data/ref_TSS_annotation/human.refTSS_v3.1.hg38.bed</code>:<ul> <li>Specifies a BED format file with FANTOM5 CAGE Peak data for annotating transcription start sites (TSS).</li> </ul> </li> <li><code>--polyA_motif_list data/polyA_motifs/mouse_and_human.polyA_motif.txt</code>:<ul> <li>Provides a ranked list of polyA motifs that are sequences often found near polyadenylation sites.</li> </ul> </li> <li><code>-o UHR_chr22</code>:<ul> <li>Sets the prefix for the output files to <code>UHR_chr22</code>.</li> </ul> </li> <li><code>-d example/SQANTI3_output</code>:<ul> <li>Designates the directory where output files will be saved: <code>example/SQANTI3_output</code>.</li> </ul> </li> <li><code>-fl example/UHR_abundance.tsv</code>:<ul> <li>Specifies a file containing full-length PacBio abundance data.</li> </ul> </li> <li><code>--short_reads example/UHR_chr22_short_reads.fofn</code>:<ul> <li>Provides a File Of File Names (fofn) with paths to FASTA or FASTQ files from short-read RNA-Seq.</li> </ul> </li> <li><code>--cpus 4</code>:<ul> <li>Sets the number of threads (or CPU cores) to be used during alignment by aligners to 4.</li> </ul> </li> <li><code>--report both</code>:<ul> <li>Specifies the report format, producing outputs in both HTML and PDF formats.</li> </ul> </li> </ul> <p>Note: The backslashes (<code>\\</code>) at the end of lines in the command are used to split a lengthy command into multiple readable lines. Each backslash indicates the continuation of the command on the next line.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#32-understanding-sqanti3-qc","title":"3.2 Understanding SQANTI3 QC:","text":"<p>SQANTI3 QC produces a series of output files following its execution, using flags like <code>--dir</code> or <code>-d</code> and <code>--output</code> or <code>-o</code> to specify the directory and file prefix, respectively. This tool also relies on other software, including STAR, kallisto, and GMST, which means there will be subfolders in the output directory. For an example output, refer to the <code>example/SQANTI3_QC_output</code> subfolder in the main SQANTI3 directory.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#321-sqanti3-transcriptome-classification-video-link-for-this-part","title":"3.2.1 SQANTI3 transcriptome classification (Video link for this part)","text":"<p>SQANTI3 sorts each isoform by comparing it to a known reference transcript. Here's how it categorizes them:</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#fsm-full-splice-match-subcategories","title":"FSM (Full Splice Match) Subcategories:","text":"<p>The reference and query isoform both have the same exon count, with each internal junction aligning to the reference. However, the exact start (5') and end (3') can vary within the first and last exons.</p> <ul> <li>Reference Match: The query isoform matches the reference isoform exactly (less than 50bp), including both internal junctions and exact 5' start and 3' end.</li> <li>5' Mismatch: The internal junctions match, but the 5' start is different (difference higher than 50bp).</li> <li>3' Mismatch: The internal junctions match, but the 3' end is different (difference higher than 50bp).</li> <li>5' and 3' Mismatch: The internal junctions match, but both the 5' and 3' ends are different (difference higher than 50bp). </li> </ul>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#ism-incomplete-splice-match","title":"ISM (Incomplete Splice Match)","text":"<p>The query isoform has fewer outer exons compared to the reference, but all internal junctions align with the reference's positions. The exact start (5') and end (3') can vary within the initial/final exons. * 5' fragments: The query isoform is missing some 5' exons compared to the reference. * 3' fragments: The query isoform is missing some 3' exons compared to the reference. * Internal fragments: Missing some start and end exons but retains the internal exons. * intron retention: Contains an intron that is usually spliced out in the reference. </p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#nic-novel-in-catalog-subcategories-nnc-novel-not-in-catalog-subcategories","title":"NIC (Novel In Catalog) Subcategories &amp; NNC (Novel Not in Catalog) Subcategories:","text":"<p>NIC (Novel In Catalog): The term \"Novel In Catalog\" (NIC) refers to a subtype of novel isoforms that are characterized by their utilization of known splice junctions. While the junctions, which are pairs of donor-acceptor sites, are previously identified and cataloged, the specific combinations in which these junctions are assembled in the isoform are novel. Essentially, NIC represents isoforms that employ previously recognized junctions in a unique or previously undocumented manner.</p> <p>NNC (Novel Not in Catalog): The \"Novel Not in Catalog\" (NNC) denotes a subtype of novel isoforms where at least one of the splice sites, either donor or acceptor, is entirely novel and has not been cataloged previously. Even if the other splice sites involved are known, the presence of a novel splice site means that the isoform falls under the NNC category. This subtype signifies isoforms that introduce new splicing patterns to the catalog due to the presence of previously unidentified splice sites.</p> <ul> <li> <p>NIC Combination of known SJ: In this category, the query isoform is formed by combining known splice junctions. In essence, even though the particular arrangement of splice junctions in the isoform is novel, all the individual splice junctions themselves have been previously cataloged.</p> </li> <li> <p>NIC Combination of known splice site: This refers to a query isoform composed of known splice sites. Splice sites are specific nucleotide sequences at the ends of introns that signal the splicing machinery. A splice site can be either a donor (at the start of an intron) or an acceptor (at the end of an intron). Even if the precise configuration or combination in the isoform hasn't been seen before, the individual splice sites have been documented previously.</p> </li> <li> <p>NIC Intron Retention: This scenario involves a query NIC isoform that retains an intron that is usually spliced out in other known isoforms.</p> </li> <li> <p>NIC Mono-exon: This scenario involves a NIC isoform that consists of a single exon without any introns.</p> </li> </ul> <p></p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#322-tss-transcription-start-site-evaluation-in-sqanti3-video-link-for-this-part","title":"3.2.2 TSS (Transcription Start Site) Evaluation in SQANTI3 (Video link for this part)","text":"<p>The accurate identification of Transcription Start Sites (TSS) stands as a cornerstone in the realm of molecular biology and genomics. TSSs are the specific locations on the DNA where transcription of a particular gene commences. Recognizing these sites with precision is pivotal.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#distance-from-the-reference-tss","title":"Distance from the Reference TSS:","text":"<ul> <li>First, it assesses how far a detected TSS falls from the reference TSS.</li> <li>The proximity of your TSS to the reference can indicate its accuracy. If it's too far off, it may be a sign of an inaccurate TSS detection.</li> </ul>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#using-cage-peaks-data","title":"Using CAGE Peaks Data:","text":"<ul> <li>Cap Analysis Gene Expression (CAGE) is a technique to identify the TSS of genes. SQANTI uses CAGE peaks data to help distinguish between true TSS and potential false positives. If the detected TSS aligns with a CAGE peak, it's more likely to be a true TSS. In contrast, if it doesn't align with any CAGE peaks, it might be a false detection.</li> <li>The TSS ratio is computed for each transcript by determining the ratio between short-read coverage downstream and upstream of the TSS. A true TSS is expected to have much lower upstream coverage, resulting in a TSS ratio greater than one. On the other hand, 5\u2019 end-degraded transcripts are expected to have uniform coverage on both sides of the TSS, leading to a TSS ratio approximately equal to one </li> </ul>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#323-sqanti3-transcriptional-termination-site-quality-control-video-link-for-this-part","title":"3.2.3 SQANTI3 Transcriptional termination site quality control (Video link for this part)","text":"<p>SQANTI3 uses three quality control metrics for evaluating transcription termination sites (TTS) in transcriptome: 1.  Distance to Annotated TTS: Measures the gap between a transcript's TTS and the nearest known TTS from reference databases to spot novel or existing termination sites. 2.  Polyadenylation (polyA) Motif Detection: Scans for a specific sequence near the 3' end of transcripts that signals for polyadenylation, serving as a biological marker for genuine TTS. 3.  Quant-seq Data Support: If available, this data provides additional validation for the 3' ends, enhancing confidence in the identified TTS.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#check-different-tts","title":"Check different TTS:","text":"<p>Distance to Annotated TTS: * What: SQANTI3 calculates the physical distance between the TTS of the newly sequenced transcript and the closest annotated TTS belonging to the same gene in reference databases. * Why: By doing this, SQANTI3 can evaluate if a transcript's TTS is novel or if it matches (or is proximate to) a previously known termination site. If a transcript's TTS is very distant from any annotated TTS, it may be a novel site or an artifact, and further validation may be needed. Polyadenylation (polyA) Motif Detection: </p> <p>Polyadenylation (polyA) Motif Detection: * What: Transcripts typically have a sequence motif near their 3' end that signals for polyadenylation (addition of a polyA tail). SQANTI3 scans the transcript sequence to detect this motif. * Why: The presence of a polyA motif can indicate a genuine TTS, as the motif is a biological marker for transcript termination and subsequent addition of a polyA tail. These detected motifs are commonly found 16-18 base pairs from the end of the transcript, consistent with known experimental evidence. This adds an extra layer of validation. Absence or unusual positioning of this motif might suggest the 3' end of the transcript was inaccurately determined or that alternative polyadenylation sites exist. </p> <p>Quant-seq Data Support (polyA site data): * What: Quant-seq is a method to sequence the 3' ends of RNAs and is used to validate the 3' ends obtained from other sequencing methods. If Quant-seq data is available, SQANTI3 considers it as orthogonal evidence to validate the TTS of a transcript. * Why: Quant-seq specifically targets the 3' end of transcripts, making it a reliable method to validate TTS. If both long-read sequencing (like from PacBio) and Quant-seq point to the same TTS, confidence in that TTS's accuracy increases.  </p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#323-sqanti3-splicing-junction-classification-video-link-for-this-part","title":"3.2.3 SQANTI3 Splicing junction classification (Video link for this part)","text":"<p>When it comes to splice junctions, here's how SQANTI approaches the task:</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#transcript-classification-based-on-splice-junctions","title":"Transcript Classification Based on Splice Junctions:","text":"<p>SQANTI classifies transcripts by comparing their splice junctions to those in a provided reference transcriptome. * Full Splice Match (FSM): Transcripts that match a reference transcript at all splice junctions. * Incomplete Splice Match (ISM): Transcripts that match consecutive, but not all, splice junctions of the reference transcripts. Those matching mostly the UTR3 sequence of their reference are labeled UTR3 Fragment. * Novel Transcripts: Transcripts introducing new splice patterns are divided into:    * Novel in Catalog (NIC): Contains either new combinations of already annotated splice junctions or novel ones formed from previously annotated donors and acceptors.    * Novel Not in Catalog (NNC): Utilizes novel donors and/or acceptors.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#canonical-vs-noncanonical-splicing","title":"Canonical vs Noncanonical Splicing:","text":"<p>Splice junctions are categorized into canonical and noncanonical based on the dinucleotide pairs at their start and end. * Canonical splicing includes the combinations GT-AG, GC-AG, and AT-AC, found in over 99.9% of human introns. * All other combinations are considered noncanonical splicing. * Users can also supply their own definitions of canonical junctions.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#splice-junction-coverage-with-short-reads","title":"Splice Junction Coverage with Short Reads:","text":"<p>SQANTI3 incorporates short-read data by internally running STAR and Kallisto for mapping and quantification of splice junction. The combination of both long and short reads provides a dual layer of evidence. If a novel splice junction is detected by both read types, there's increased confidence in its authenticity. Unlike SQANTI, SQANTI3 can process raw FASTQ files from Illumina directly, producing short read-related metrics. Here are the details of how SQANTI3 processes short reads data:</p> <ol> <li>A genome index is prepared and short reads are mapped using STAR.</li> <li>The mapping does not use a reference annotation, ensuring that SJ identification is not influenced by previous annotations.</li> <li>STAR's parameters follow the ENCODE-DCC RNA-seq protocol. To enhance novel SJ detection, the <code>--twopassMode</code> option is turned on.</li> <li>Post STAR execution, two files are generated per replicate: <code>SJ.out.tab</code>, which provides quantification of long-read-defined SJs by short reads, and a BAM file, utilized for the novel TSS ratio metric computation.</li> </ol> <p></p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#324-sqanti3-intra-priming-video-link-for-this-part","title":"3.2.4 SQANTI3 Intra-priming (Video link for this part)","text":"<p>Researchers use specific oligos, anywhere between 20-35 bases long, called primers, to initiate the copying or amplifying process of DNA. Typically, an 'oligodT' primer is custom-designed to match the target sequence at the end of a transcript, which often has a long string of 'A's known as the polyA tail. However, given that there are also A-rich regions within the transcripts (not just at the end), the oligodT primer might inadvertently begin amplification from these internal regions instead. If these transcripts don't have a typical ending (consensus poly Adenilation site), SQANTI thinks they might be mistakes from internal priming and flags them. This transcripts can be eliminated using </p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#mechanisms-intra-priming","title":"Mechanisms Intra-priming:","text":"<ul> <li>Imagine your DNA is a long string of letters, with 'A' being one of them. Sometimes, there's a region in the DNA that has lots of 'A's, either 6 of them in a row or 12 out of a group of 20 letters.</li> <li>When a small piece of DNA (or a primer) finds this A-rich area, it can stick to it and start copying the DNA from there. </li> <li>This is called \"internal priming\" because it's happening inside the DNA sequence and not where it's supposed to be.</li> </ul> <p>SQANTI3 checks for this by looking at transcripts and seeing if there's a very A-rich region (&gt;= 80% A's in the last 20 letters) at their end. </p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#325-sqanti3-rt-switching-video-link-for-this-part","title":"3.2.5 SQANTI3 RT-switching (Video link for this part)","text":"<p>RT-switching refers to the \"jumping\" or switching of the reverse transcriptase enzyme between repeated regions of an RNA molecule due to its secondary structure. This can lead to the formation of cDNA molecules that don't accurately represent the original RNA sequence and can introduce artifacts when analyzing RNA sequences or structures. </p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#heres-a-step-by-step-explanation-of-rt-switching","title":"Here's a step-by-step explanation of RT-switching:","text":"<ol> <li>Reverse Transcription Start: The process begins with the initiation of reverse transcription. This is where the reverse transcriptase enzyme (RT) starts transcribing RNA into complementary DNA (cDNA). The RNA molecule has a secondary structure and repeated regions which play a role in RT-switching.</li> <li>RNA Secondary Structure and Repeated Regions: RNA molecules can form secondary structures due to complementary base pairing within the molecule itself. These structures may bring repeated regions into close proximity. When the RT enzyme encounters these structures, it might jump from one repeated region to another.</li> <li>Formation of cDNA with Skipped Repeats: When the RT enzyme switches or \"jumps\" between repeated regions, the resulting cDNA molecule may not have all the repeated regions that were originally present in the RNA. Instead, the cDNA will possess only one copy of the direct repeats.</li> <li>Novel Splice Junctions Appear: When the cDNA, which has undergone RT-switching, is sequenced or mapped, it might appear as though it has novel splice junctions. These are not true biological splice junctions but are artifacts caused by the RT-switching event. </li> </ol> <p>SQANTI3 identifies these potential artifacts by checking for the presence of direct repeats in the sequence. This search is performed in a region of a user-defined number of bases around the splice junctions. If a matching patter is found within the exon and intron sequences, the junction is flagged as a RT-switching artifact, and all the isoforms containing this junction are classified as \"RT-switching\".</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#4-executing-and-understanding-sqanti3-filter-video-link-for-this-part","title":"4. Executing and Understanding SQANTI3 Filter   (Video link for this part)","text":"<p>SQANTI3 has enhanced its filtering capabilities by improving its machine learning-based filter and introducing a flexible rules-based strategy, allowing users to discern between true isoforms and artifacts more accurately. </p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#41-sqanti3-rules-filter-video-link-for-this-part","title":"4.1 SQANTI3 rules filter (Video link for this part)","text":"<p>SQANTI3 has a rules-based strategy for filtering, which is especially useful when defining TP and TN sets is challenging. Here, a JSON file is used to specify the characteristics of a reliable isoform. The file is comprised of rules, with each rule consisting of multiple requisites. All requisites of a rule must be met for a transcript to be deemed true. Multiple rules for the same category are evaluated independently, and a transcript only needs to pass one of these rules. SQANTI3 comes with a default JSON file that includes rules for a basic filter. However, users can create their own JSON files to define custom rules.</p>  Default rules filter  <pre><code>{\n    \"full-splice_match\": [\n        {\n            \"perc_A_downstream_TTS\":[0,59]\n        }\n    ],\n    \"rest\": [\n        {\n            \"perc_A_downstream_TTS\":[0,59],\n            \"all_canonical\":\"canonical\",\n            \"RTS_stage\":\"FALSE\"\n        },\n        {   \n            \"perc_A_downstream_TTS\":[0,59],\n            \"RTS_stage\":\"FALSE\",\n            \"min_cov\":3\n        }\n     ]\n}\n</code></pre> <p></p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#411-rules-filter-example","title":"4.1.1 Rules filter example:","text":"<p>To filter a classification file and generate outputs with the prefix \"filtered_results\", you can use:</p> <pre><code>python sqanti3_filter.py rules --sqanti_class path/to/classification.txt -o filtered_results\n</code></pre> <p>Note: this will apply default filters and produce filtered files with the \"filtered_results\" prefix in the directory where the script is run.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#required-arguments","title":"Required Arguments:","text":"<ul> <li><code>--sqanti_class</code>: Path to the SQANTI3 QC classification file.</li> </ul>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#optional-arguments","title":"Optional Arguments:","text":"<ul> <li><code>-h</code>, <code>--help</code>: Displays help message and exits.</li> <li><code>--isoAnnotGFF3 ISOANNOTGFF3</code>: Path to the isoAnnotLite GFF3 file that is to be filtered.</li> <li><code>--isoforms ISOFORMS</code>: Path to the fasta/fastq isoform file that is to be filtered.</li> <li><code>--gtf GTF</code>: Path to the GTF file that is to be filtered.</li> <li><code>--sam SAM</code>: Path to the SAM alignment of the input fasta/fastq.</li> <li><code>--faa FAA</code>: Path to the ORF prediction faa file to be filtered by SQANTI3.</li> <li><code>-o OUTPUT</code>, <code>--output OUTPUT</code>: Specifies the prefix for output files.</li> <li><code>-d DIR</code>, <code>--dir DIR</code>: Sets the directory for output files. Default is the directory where the script was run.</li> <li><code>-v</code>, <code>--version</code>: Displays the program version number.</li> <li><code>--skip_report</code>: When supplied, the filter will not generate a report.</li> <li><code>-j JSON_FILTER</code>, <code>--json_filter JSON_FILTER</code>: Specifies the JSON file where filtering rules are expressed. By default, the filter uses <code>utilities/filter/filter_default.json</code>.</li> </ul>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#414-understand-how-to-create-sqanti3-rules","title":"4.1.4 Understand how to create SQANTI3 rules","text":""},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#creating-custom-filters","title":"Creating Custom Filters:","text":"<ul> <li>Starting with SQANTI3 version 5.0, users can specify any number of filtering rules in a JSON file.</li> <li>The structure involves defining rules for each structural category, with each rule made up of various requisites.<ul> <li>Rules for a category are treated as logical OR.</li> <li>Requisites within a rule are treated as logical AND.</li> </ul> </li> <li>The \"rest\" category can be used to specify rules for all other unspecified categories.</li> </ul>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#rule-structure-in-json","title":"Rule Structure in JSON:","text":"<ul> <li>Rules can be set for any numeric or character column in the classification file:<ul> <li>Numeric columns: Define an interval ([X,Y]) or just the lower limit.</li> <li>Character/logical columns: Define which terms or values are accepted. </li> </ul> </li> </ul>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#example-of-user-defined-filter-video-link-for-this-part","title":"Example of User-defined Filter (Video link for this part):","text":"<ol> <li> <p>Full Splice Match category:</p> <ul> <li>Isoforms must not be a potential intra-priming product. They should have less than 60 percent of genomic adenines in the downstream 20 BP window. </li> </ul> </li> <li> <p>Incomplete Splice Match category:</p> <ul> <li>Isoform must be larger than two kilobases and shorter than 15 kilobases.</li> <li>Must be cataloged within the three prime fragments, five Prime fragments, or internal fragment subcategories. </li> </ul> </li> <li> <p>Novel In the Catalog category:</p> <ul> <li>All splice junctions should be canonical or covered by at least 10 short reads. </li> </ul> </li> <li> <p>Novel Not in the Catalog category:</p> <ul> <li>All splice junctions should be canonical.</li> <li>The absolute distance to the closest annotated transcriptional start sites and transcriptional termination sites must be 50 BP or less or covered by at least 10 short reads. </li> </ul> </li> <li> <p>Rest of the Categories:</p> <ul> <li>Transcripts will be kept if:<ul> <li>They are not suspected of being an RT switching artifact.</li> <li>All of their splice junctions are canonical.</li> <li>The transcript is coding.</li> <li>It is not an intra-priming product.</li> <li>It is not a mono exon transcript.</li> </ul> </li> </ul> </li> </ol> <p></p> <p>An example JSON filter is provided that defines rules for different isoform categories, including \"full-splice_match\", \"incomplete-splice_match\", \"novel_in_catalog\", \"novel_not_in_catalog\", and \"rest\". This filter specifies various conditions for keeping isoforms, such as avoiding potential intrapriming products, setting length thresholds, and requiring canonical splice junctions.</p> <p>In summary, SQANTI3 provides a flexible way for users to filter their transcriptomes based on specific criteria to curate high-quality transcript sets. This is facilitated through easy-to-define JSON-based rule sets.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#42-sqanti3-machine-learning-filter-video-link-for-this-part","title":"4.2 SQANTI3 Machine Learning Filter (Video link for this part)","text":"<p>SQANTI3 has enhanced its machine learning-based filter (ML filter) from its predecessors. The filter, rooted in a random forest classifier, discerns between true isoforms and artifacts. The training relies on SQANTI3's QC attributes and the selection of true positive (TP) and true negative (TN) isoform sets. Users can now define these sets or let the software automatically pick them based on SQANTI3's classifications. By default, the filter considers NNC non-canonical isoforms as TN and reference match (RM) subcategories as TP. There's a balance in set size for training, and a default threshold is set where the transcript's likelihood of being a genuine isoform must be \u22650.7. Users can adjust this threshold and specify which isoforms are included or excluded. The filter now benefits from new validation metrics and additional data like CAGE-seq peaks, the short read-based TSS ratio metric, polyA motif details, and Quant-seq peaks. This allows for better artifact detection. Rules for model training can be customized to avoid overfitting. The classifier's output modifies the original <code>*_classification.txt</code> file to produce a <code>*_ML_result_classification.txt</code> file.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#421-example-command","title":"4.2.1 Example command:","text":"<pre><code>python sqanti3_filter.py ml --sqanti_class path/to/classification.txt\n</code></pre>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#required-arguments_1","title":"Required arguments:","text":"<ul> <li><code>--sqanti_class</code>: SQANTI3 QC classification file.</li> </ul>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#optional-arguments_1","title":"Optional arguments:","text":"<ul> <li><code>--isoAnnotGFF3</code>: Specifies the isoAnnotLite GFF3 file to be filtered.</li> <li><code>--isoforms</code>: Designates the fasta/fastq isoform file for filtering.</li> <li><code>--gtf</code>: Indicates the GTF file for filtering.</li> <li><code>--sam</code>: Signifies the SAM alignment of the input fasta/fastq.</li> <li><code>--faa</code>: Represents the ORF prediction faa file for SQANTI3 filtering.</li> <li><code>-o, --output</code>: Prefix for output files.</li> <li><code>-d, --dir</code>: Output directory (default is the directory where the script was run).</li> <li><code>-e, --filter_mono_exonic</code>: Filters all mono-exonic transcripts by default.</li> <li><code>-v, --version</code>: Shows program version number.</li> <li><code>--skip_report</code>: Skips creating a filtering report.</li> <li><code>-t, --percent_training</code>: Data proportion for training (default is 0.8 or 80%).</li> <li><code>-p, --TP</code>: Path to file listing TP transcripts.</li> <li><code>-n, --TN</code>: Path to file listing TN transcripts.</li> <li><code>-j, --threshold</code>: Probability threshold to classify as positive isoforms (default is 0.7).</li> <li><code>-f, --force_fsm_in</code>: Forces the inclusion of FMS transcripts regardless of ML results.</li> <li><code>--intermediate_files</code>: Outputs intermediate files from ML filter.</li> <li><code>-r, --remove_columns</code>: Provides path to file with names of columns to be excluded during training.</li> <li><code>-z, --max_class_size</code>: Max number of isoforms for TP and TN sets (default is 3000).</li> <li><code>-i, --intrapriming</code>: Sets adenine percentage to flag an isoform as intra-priming (default is 60).</li> </ul> <p>For an in-depth understanding of each parameter, you can delve into the detailed descriptions in the filter wiki page. The ML filter allows users to define TP and TN sets or utilize the built-in sets. After defining the sets, you'll split them for model training/testing. The ML filter will utilize the probability threshold to label transcripts as Isoforms or Artifacts.</p> <p>Additionally, certain columns from the classification table are omitted before running the SQANTI3 ML filter. Users have the liberty to exclude more columns if needed. There's an intra-priming filter included in the script and options to enforce the removal or retention of specific isoform groups.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#424-understand-how-the-machine-learning-filter-works","title":"4.2.4 Understand how the machine learning filter works","text":"<p>In machine learning, especially for supervised learning tasks, training data is pivotal. The model's ability to accurately predict or classify unseen data depends largely on the quality and quantity of the training data. In the context of the SQANTI3's machine learning filter, let's delve deeper into the nuances of training data and the model.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#1-true-positive-tp-and-true-negative-tn-sets","title":"1. True Positive (TP) and True Negative (TN) Sets","text":"<p>Selection Criteria for TP and TN sets:</p> <ul> <li>True Positive (TP): Reliable isoforms from which the model learns the features of a genuine isoform. The built-in selection includes Reference Match (RM) isoforms, and if there are insufficient RM isoforms, Full-Splice Match (FSM) isoforms are taken as TP.</li> <li>True Negative (TN): These are isoforms considered as low-quality or artifacts. The built-in selection encompasses Novel Not in Catalog (NNC) isoforms with at least one non-canonical junction. If this group is small, all NNC isoforms are used as TN.</li> </ul> <p>Users can supply their own TP and TN sets, tailoring the training data to their specific requirements. If the user has prior knowledge about certain transcripts being genuine isoforms or artifacts, this functionality becomes valuable.</p> <p>SQANTI3 looks for a balance in the training sets. If there's a significant disparity between the sizes of the TP and TN sets, the larger set is downsized through random sampling to match the smaller set size. This ensures balanced training and avoids bias towards the over-represented class.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#2-partitioning-the-training-data","title":"2. Partitioning the Training Data","text":"<p>Before training the model, it\u2019s important to divide the dataset into training and testing sets. Typically, 80% of the data is used for training, while the remaining 20% is set aside for testing. This approach allows the model to learn from the majority of the data while still being evaluated on data it hasn\u2019t seen before, giving a clearer picture of how well it generalizes. To further strengthen the model\u2019s reliability, SQANTI3 uses a 10-fold cross-validation technique during training. This means the training data is split into 10 equal parts\u2014nine are used to train the model, and the remaining one is used for validation. This process repeats 10 times, cycling through each part. The goal is to reduce overfitting and ensure the model performs consistently across different subsets of data.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#3-random-forest-classifier","title":"3. Random Forest Classifier","text":"<p>The classification itself is handled by a Random Forest model, which is a popular ensemble learning method. It works by combining the predictions of multiple decision trees, offering a balance between flexibility and accuracy. Random Forests are particularly good at managing complex datasets with many features. In SQANTI3, the model is trained using the <code>caret</code> package in R, and it draws on a variety of transcript-derived features like transcript length, number of exons, and junction patterns. After training, the model doesn\u2019t just spit out a yes or no\u2014it assigns each transcript a probability score indicating how likely it is to be a true isoform. By default, transcripts scoring above 0.7 are considered genuine.</p> <p>To evaluate how well the model performs, the reserved 20% of testing data comes back into play. This separate data helps confirm whether the model's predictions hold up in practice. Once the model is trained and tested, it\u2019s saved as an .RData file. If you run the filtering step again in the same directory, SQANTI3 will reuse this saved model to skip retraining. That\u2019s useful when you want to apply a trained model to new data. However, if you want to train a fresh model instead, you'll need to move or delete the existing one first.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#4-feature-importance-and-exclusion","title":"4. Feature Importance and Exclusion","text":"<p>Not all features in a dataset are equally useful\u2014some may have little impact on the model\u2019s performance, while others might even introduce unwanted bias. To address this, SQANTI3 offers the flexibility to exclude specific features or columns from the training process. This allows users to fine-tune the model by focusing only on the most informative data, helping to reduce noise and improve overall accuracy.</p> <p>By leaving out certain columns, users can also guard against overfitting. If a model becomes too dependent on features that are only relevant within the training set, it may struggle to generalize to new data. Excluding such features ensures the model remains robust and applicable beyond the specific dataset it was trained on.</p> <p></p> <p>Note The random forest classifier has specific scenarios where it might not run, so be mindful of exceptions.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#5-executing-and-understanding-sqanti3-rescue-video-link-for-this-part","title":"5. Executing and Understanding SQANTI3 Rescue (Video link for this part)","text":"<p>The SQANTI3 rescue module is designed to prevent the loss of transcripts from long-read data that could not be accurately processed. It aims to identify valid transcript models for transcripts initially discarded due to potential artifacts after filtering using the SQ3 filter module. Full documentation can be found in the rescue wiki page.</p> <p></p> <p>SQANTI3 rescue offers two main modes of operation: automatic and full. The automatic mode, which is the default, focuses on recovering high-confidence reference isoforms by identifying reference transcripts for which all corresponding Full Splice Match (FSM) isoforms were removed during the filtering stage, under the assumption that their junction structures are likely correct. On the other hand, the full mode extends the rescue process to consider ISM, NIC, and NNC artifacts as rescue candidates. This mode involves a more comprehensive strategy, including mapping these candidate artifacts to potential target transcripts from both the reference and long-read datasets using minimap2, followed by applying the SQANTI3 filter to the reference targets and a final selection of rescued transcripts based on the mapping results and filter outcomes.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#51-automatic-rescue","title":"5.1 Automatic rescue:","text":"<p>The automatic rescue process in SQANTI3 identifies and restores isoforms that were classified as artifacts during filtering but are likely to be biologically relevant. The process focuses on rescuing the reference transcripts where all of the full-splice match (FSM) isoforms have been removed. It only rescues mono-exonic FSM isoforms if the user specifies this option (<code>--rescue_mono_exonic</code>). If a reference transcript has an associated FSM isoform that was determined as artifact, it is rescued if it is not already present in the final set. This approach ensures that potentially important transcripts, particularly those matching reference annotations, are not lost due to stringent filtering criteria.</p> <pre><code>sqanti3_rescue.py rules --filter_class  example/rules_filter_output/ \\\n                        --refGTF data/reference/gencode.v38.basic_chr22.gtf \\\n                        --refFasta data/reference/GRCh38.p13_chr22.fasta \\\n                        --mode automatic \\\n                        --dir pablo_tests/rescue_automatic --output UHR_chr22\n</code></pre> <p>This will generate a list with the reference transcripts that have been rescued (if any) and the updated GTF file with the final rescued transcriptome. This can be further expanded by using the <code>--mode full</code> option, which will include all the ISM, NIC and NNC artifacts as potential rescue candidates. </p> <p>Note: You will have to specify either <code>rules</code> or <code>ml</code> for the rescue mode, based on the filter strategy used and the corresponding classification file.</p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#52-full-rescue","title":"5.2 Full rescue:","text":"<p>The first step in the full rescue is to select the candidate isoforms and the target reference transcripts to rescue. </p> <ul> <li>Candidate isoforms: These will be ISM, NIC and NNC isoforms that were classified as artifacts during the filtering step. </li> <li>Target reference transcripts: In this group, we will include all of the isoforms that belong to the associated genes of the candidate isoforms. This includes the reference transcripts from those genes and the long-read isoforms that were classified as FSM. </li> </ul> <p>Once the candidate isoforms and the target reference transcripts are selected, we will map the candidate isoforms to the target reference transcripts using minimap2. This mapping will be used to identify the best matching target transcript for each candidate isoform.</p> <p>Before doing the final rescue, we need to treat the reference annotation as if it were a long-read dataset, in this case, the same one as our inupt. For that reason, you will have to run SQANTI3 QC with the same parameters and orthogonal data as you did with your long-read dataset. Once that is done, you will have to run rescue in either rules or ML mode, depending on the filter strategy you used.  </p>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#rules-based-rescue","title":"Rules-based rescue","text":"<p>If the rules strategy was used, you will have to reuse the same JSON file that was used to filter the long-reads transcriptome. </p> <pre><code>sqanti3_rescue.py rules \\\n    --filter_class example/rules_filter_output/UHR_chr22_RulesFilter_result_classification.txt \\\n    --refGTF data/reference/gencode.v38.basic_chr22.gtf \\\n    -refFasta data/reference/GRCh38.p13_chr22.fasta \\\n    --rescue_isoforms example/SQANTI3_QC_output/UHR_chr22_corrected.fasta \\\n    --rescue_gtf example/rules_filter_output/UHR_chr22.filtered.gtf \\\n    --refClassif data/reference/gencode.v38.basic_chr22_classification.txt \\\n    --mode full \\\n    --json_filter src/utilities/filter/filter_default.json \\\n    --dir example/rescue_full_rules --output UHR_chr22 \n</code></pre>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#machine-learning-based-rescue","title":"Machine learning-based rescue","text":"<p>If the ML strategy was used, in this case you will have to directly give SQANTI3 the random forest model that was trained during the filtering step. The rest of the parameters should be the same as with the rules-based rescue. </p> <pre><code>sqanti3_rescue.py ml \\\n    --filter_class example/rules_filter_output/UHR_chr22_ML_result_classification.txt \\\n    --refGTF data/reference/gencode.v38.basic_chr22.gtf \\\n    -refFasta data/reference/GRCh38.p13_chr22.fasta \\\n    --rescue_isoforms example/SQANTI3_QC_output/UHR_chr22_corrected.fasta \\\n    --rescue_gtf example/rules_filter_output/UHR_chr22.filtered.gtf \\\n    --refClassif data/reference/gencode.v38.basic_chr22_classification.txt \\\n    --mode full \\\n    --random_forest example/ml_filter_output/randomforest.RData \\\n    --dir example/rescue_full_rules --output UHR_chr22 \n</code></pre>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#522-rescued-isoforms-selection","title":"5.2.2 Rescued isoforms selection","text":"<p>Once we have the mapping of the candidate isoforms to the targets and the reference annotation has been filtered as the long-reads dataset, the final step of rescue is to select the transcripts that will be rescued. The reintroduction of targets into the final transcriptome is done if they pass the following steps:</p> <ol> <li>Pass the applied SQANTI3 filter criteria (independently of being a reference transcript/gene or a long-read isoform).</li> <li>In the case of having two possible targets where one is a long-read isoform and the other is a reference transcript, the latter will be selected, since the best matching transcript is already part of the transcriptome.</li> <li>The target transcript will be rescued if it does not introduce redundancy into the final transcriptome. This means that if the target transcript is already present in the final transcriptome, it will not be rescued again.</li> </ol>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#52-the-main-principles-of-sqanti3-rescue","title":"5.2 The Main Principles of SQANTI3 rescue:","text":"<ol> <li>Consistent Quality: Rescued transcript models should satisfy the quality control (QC) standards set during the filtering phase.</li> <li>Non-redundancy: If the replacement transcript (identified for an artifact) already exists in the filtered transcriptome, it isn't added again.</li> </ol>"},{"location":"Tutorial%3A-running-SQANTI3-on-an-example-dataset/#53-understand-the-process-of-sqanti3-rescue","title":"5.3 Understand the Process of SQANTI3 rescue:","text":"<ol> <li> <p>Automatic Rescue:</p> <ul> <li>Targets FSM (Full Splice Match) artifacts arising when there's insufficient confidence in validating Transcription Start Sites (TSS) or Transcription Termination Sites (TTS).</li> <li>If a reference transcript relates to a removed FSM, it's automatically added to the transcriptome. However, if multiple FSMs point to the same reference but have varied TSS, the reference is added just once.</li> <li>Artifacts from ISM, NIC, and NNC categories are seen as potential rescue candidates. ISM artifacts are considered only if they don't have an associated FSM with the same reference transcript.</li> <li> <p>Rescue Target Identification:</p> </li> <li> <p>Defines a group of \"rescue targets\" or potential replacements for the rescue candidates. This encompasses both long read-defined and reference isoforms that have at least one same-gene rescue target.</p> </li> <li>Candidates are mapped to the targets in a \"rescue-by-mapping\" process. The tool used here is minimap2, set for long-read alignment.</li> <li> <p>Quality Control:</p> </li> <li> <p>Ensures the reference transcriptome targets used in the rescue adhere to the same QC standards as the long-read targets.</p> </li> <li>The SQANTI3 QC and Filter modules (machine learning or rules) are applied on the reference transcriptome, ensuring the same data and quality standards as were used for the long-read transcript models.</li> <li> <p>Final Selection:</p> </li> <li> <p>Filters out mapping hits if the rescue target didn't pass the established filters.</p> </li> <li>If multiple valid mapping hits exist per candidate, the one with the highest probability (from either long-read or reference) will be chosen. If more than one hit passes the rules filter, all targets are considered.</li> <li>If the best matching target is a long read-defined isoform already in the transcriptome, nothing changes since the artifact is already represented.</li> <li>The remaining reference targets are checked for redundancy and added only if they aren't present in the already curated transcriptome.</li> </ul> </li> </ol> <p>In essence, the SQANTI3 rescue module seeks to ensure no valuable transcript data is lost while maintaining stringent quality and non-redundancy principles.</p>"},{"location":"Understanding-the-output-of-SQANTI3-QC/","title":"Understanding the output of SQANTI3 QC","text":""},{"location":"Understanding-the-output-of-SQANTI3-QC/#table-of-contents","title":"Table of contents:","text":"<ul> <li> <p>SQANTI3 QC output</p> <ul> <li> <p>Main output</p> </li> <li> <p>Transcriptome files</p> </li> <li> <p>Report</p> </li> <li> <p>Supplementary output</p> </li> </ul> </li> <li> <p>Glossary of classification file columns </p> </li> <li> <p>Glossary of junction file columns </p> </li> </ul> <p></p>"},{"location":"Understanding-the-output-of-SQANTI3-QC/#sqanti3-qc-output","title":"SQANTI3 QC output","text":"<p>As a result of running SQANTI3 QC, the tool will create a series of output files in the specified directory (<code>--dir</code> or <code>-d</code> flag in the QC script), all of which will be named using the supplied prefix (<code>--output</code> or <code>-o</code> flag in the QC script). Given that SQANTI3 also runs several other tools internally (e.g. STAR, kallisto, GMST...), a series of subfolders will also appear in the output directory. </p> <p>The example/SQANTI3_QC_output subfolder in the SQANTI3 main directory contains an updated example of what the output of SQ3 QC looks like:</p> <p>[[https://github.com/aarzalluz/figures_public/blob/master/SQANTI3/example_output_SQ3-QC.png]]</p> <p>This is the result of running SQANTI3 QC on example data, i.e. a subset of the UHR dataset. A more detailed explanation of the different output files included below.</p> <p></p>"},{"location":"Understanding-the-output-of-SQANTI3-QC/#main-output-classification-and-junctions-files","title":"Main output: classification and junctions files","text":"<p>SQANTI3 characterizes the input transcriptome by computing a series of attributes by transcript, which are written to the classification file, and a series of attributes by junction, which are written to the junctions file.</p> <ul> <li> <p>Classification file: a tab-separated file where transcripts are rows and QC attributes computed by SQANTI3 are columns. Isoforms are identified by their ID in the input long-read GTF file. For a full glossary of columns and their meaning, see below.</p> </li> <li> <p>Juctions file: a tab-separated file containing each junction for every PB isoform as rows. Rows are identified by the isoform ID and the junction number (shown in order, i.e. the 1st, 2nd, 3rd... ith junction), which are included in the two first columns. Take into account that the same junction may appear multiple times if they are shared by multiple PB isoforms, for instance, when several FSM and ISM transcripts associated to the same reference isoform are found. For a full glossary of columns and their meaning, see below</p> </li> </ul> <p></p>"},{"location":"Understanding-the-output-of-SQANTI3-QC/#transcriptome-files","title":"Transcriptome files","text":"<ul> <li> <p>GTF file: the <code>_corrected.gtf</code> file constitutes the main transcriptome output of SQANTI3. It contains the annotation for all transcripts supplied to SQANTI3. This file may be used for downstream analyses such as quantification, however, we recommend filtering your transcriptome using the QC attributes in SQANTI3 before proceeding with your analyses. For this purpose, you may apply one of the two filters available in SQANTI3 or, alternatively, define your own filtering criteria.</p> </li> <li> <p>FASTA file: the <code>_corrected.fasta</code> file contains the genomic sequences of transcripts supplied to SQANTI3 QC, obtained using the <code>_corrected.gtf</code> file and the provided reference genome.</p> </li> <li> <p>FAA file: the <code>_corrected.faa</code> file contains FASTA-formatted protein sequences derived from transcript sequences. These sequences are obtained by running the GeneMark (GMST) ORF prediction algorithm and will not be output if the <code>--skipORF</code> flag is supplied.</p> </li> <li> <p>CDS GFF file: the <code>_corrected.gtf.cds.gff</code> file is generated by expanding the GTF file to include coding sequence (CDS) information (obtained from GMST ORF predictions). This means that, in addition to exons and transcripts, CDS will also be included as a feature in the 3rd GFF column.</p> </li> <li> <p>tappAS GFF3 file (optional): if the <code>--isoAnnotLite</code> argument is used, IsoAnnotLite will be run internally and a tappAS-formatted GFF3 file containing all isoforms in the input transcriptome generated in the output folder. This allows direct usage of a SQANTI3-processed transcriptome in tappAS. Of note, if a pre-annotated tappAS GFF3 file is supplied to SQANTI3 QC via the <code>--gff3</code> flag, the tappAS GFF3 annotation will also contain functional feature transferred by position (see details on how IsoAnnotLite works here).</p> </li> </ul>"},{"location":"Understanding-the-output-of-SQANTI3-QC/#note-on-indel-correction-and-gtffasta-output-files","title":"Note on indel correction and GTF/FASTA output files","text":"<p>SQ3 currently accepts both GTF (default) and FASTA transcriptome files as input. If a FASTA input file is supplied, sequences are mapped to the genome to generate the <code>_corrected.gtf</code> file. Using this GTF and the reference genome, SQ3 performs indel correction and generates the <code>_corrected.fasta</code> file. Please note that this type of reference-based correction will remove SNPs, therefore, users who are interested in this kind of information should refrain from using a FASTA file as input. Alternatively, if users supply a GTF input file, SQ3 will NOT perform indel correction, just extract transcript sequences using the reference genome and the transcriptome GTF file, which will be equivalent to the <code>_corrected.gtf</code> file.</p> <p></p>"},{"location":"Understanding-the-output-of-SQANTI3-QC/#sqanti-qc-report","title":"SQANTI QC report","text":"<p>The SQANTI QC report is generated by the SQANTI3_report.R script, which takes the classification (e.g. <code>UHR_chr22_classification.txt</code>) and junctions (e.g. <code>UHR_chr22_junctions.txt</code>) files. </p> <p>The report includes over 150 plots, therefore, in order to ease interpretation, we recently implemented the <code>--report</code> argument with four options: <code>pdf</code>, <code>html</code>, <code>both</code> and <code>skip</code>. This means that the report can be created as an interactive HTML document as well as (or alternatively to) a PDF report -or skipped entirely if the user does not wish to see a report for the QC run.</p> <p>Users who are proficient in R are welcome to modify the R script to add new figures -we will be constantly adding new figures as well.</p> <p></p>"},{"location":"Understanding-the-output-of-SQANTI3-QC/#supplementary-output","title":"Supplementary output","text":"<ul> <li>Parameter file (<code>_params.txt</code>): plain text file including the full paths of all files supplied to SQANTI3, as well as any additional parameters included in the call to <code>sqanti3_qc.py</code>. Here is an example the fields included in the parameter file for a full SQ3 QC run starting from raw short-read data.</li> </ul> <pre><code>Version 5.0\nInput   /path/to/transcriptome/long-read_transcripts.gtf\nAnnotation      /path/to/reference_annotation/reference.gtf\nGenome  /path/to/reference_genome/genome.fasta\nMinRefLength    200\nForceIdIgnore   False\nAligner minimap2\nFLCount /path/to/FL_counts/transcripts.collapsed.abundance.txt\nExpression      NA\nJunction        /path/to/mapping_results/STAR_mapping\nCAGEPeak        /path/to/CAGE_file/CAGE_peaks.bed\nPolyAMotif      /path/to/polyA_file/polyA_motif-list.txt\nPolyAPeak       /path/to/polyA_files/polyA_peaks.bed\nIsFusion        False\nPhyloP  NA\nSkipORF False\nORFInput        NA\nFASTAused       False\nExpression      NA\nGMAPindex       NA\nOutputPrefix    SQANTI3\nOutputDirectory /path/to/SQANTI3_output/\nCoverage        /path/to/mapping_results/STAR_mapping\nCanonicalSites  ATAC,GCAG,GTAG\nPostTTSWindow   20\nGeneName        False\nReportType      both\nRunIsoAnnotLite False\nisoAnnotGFF3    NA\nShortReads      /path/to/raw_data/SR.fofn\nShortReadsBAMs  /path/to/raw_data/SR_bams.fofn\n\n</code></pre> <ul> <li> <p>STAR folders contain the different outputs of the STAR aligner, which is run internally using provided short-reads during QC.</p> </li> <li> <p>STAR_index: STAR index for the supplied reference genome. If you wish to supply a pre-computed index to SQ3 QC, see the shortcut described in issue #130.</p> </li> <li> <p>STAR_mapping: STAR mapping files. SQANTI3 uses short-read coverage information (<code>_SJ.out.tab</code> file) and mapping BAM files (<code>_Aligned.sortedByCoord.bam</code>) to compute short-read coverage, isoform expression (see kallisto output below) and the TSS ratio metric.</p> </li> <li> <p>Kallisto output folder: this folder will contain the results of running kallisto to compute isoform expression estimates using the different short-read replicates supplied. In it, users will find one subfolder per replicate, in which kallisto abundance files (i.e. quantification matrices) are stored.</p> </li> <li> <p>RT-switching (RTS) folder: output files generated by the RT-switching prediction script (<code>utilities/rt_switching.py</code>).</p> </li> <li> <p>GMST folder: output files generated after running GeneMarkST (<code>utilities/gmst</code>) for ORF prediction.</p> </li> <li> <p>genePred files: reference annotation and long-read transriptome GTF files are converted to genePred format during isoform classification. The two <code>.genePred</code> files found in the output folder constitute the intermediate files that are generated in this process.</p> </li> </ul> <p></p>"},{"location":"Understanding-the-output-of-SQANTI3-QC/#glossary-of-classification-file-columns-classificationtxt","title":"Glossary of classification file columns (<code>classification.txt</code>)","text":"<p>The output <code>_classification.txt</code> has the following fields:</p> <ol> <li><code>isoform</code>: the isoform ID. Usually in <code>PB.X.Y</code> format.</li> <li><code>chrom</code>: chromosome.</li> <li><code>strand</code>: strand.</li> <li><code>length</code>: isoform length.</li> <li><code>exons</code>: number of exons.</li> <li><code>structural_category</code>: one of the categories [\"full-splice_match\", \"incomplete-splice_match\", \"novel_in_catalog\", \"novel_not_in_catalog\", \"genic\", \"antisense\", \"fusion\", \"intergenic\", \"genic_intron\"]</li> <li><code>associated_gene</code>: the reference gene name.</li> <li><code>associated_transcript</code>: the reference transcript name.</li> <li><code>ref_length</code>: matched reference transcript length. For transcripts in the <code>novel_in_catalog</code> and <code>novel_not_in_catalog</code> categories, the best matching reference transcript is chosen based on the highest number of shared splice junctions and the smallest difference in exon count.</li> <li><code>ref_exons</code>: reference transcript number of exons.</li> <li><code>diff_to_TSS</code>: distance of query isoform 5' start to reference transcript start end. Negative value means query starts downstream of the reference TSS, so the transcript is shorter than reference transcript.</li> <li><code>diff_to_TTS</code>: distance of query isoform 3' end to reference annotated end site. Negative value means query ends upstream of TTS, so the transcript is shorter than reference transcript.</li> <li><code>diff_to_gene_TSS</code>: distance of query isoform 5' start to the closest start end of any transcripts of the matching gene. This field is different from <code>diff_to_TSS</code> since it's looking at all annotated starts of a gene. Negative value means query starts downstream of TSS.</li> <li><code>diff_to_gene_TTS</code>: distance of query isoform 3' end to the closest end of any transcripts of the matching gene. Negative value means query ends upstream of TTS.</li> <li><code>subcategory</code>: additional splicing categorization, separated by semi-colons. Categories include: <code>mono-exon</code>, <code>multi-exon</code>. Intron rentention is marked with <code>intron_retention</code>. </li> <li><code>RTS_stage</code>: TRUE if one of the junctions could be a RT switching artifact.</li> <li><code>all_canonical</code>: TRUE if all junctions have canonical splice sites.</li> <li><code>min_sample_cov</code>: sample with minimum coverage.</li> <li><code>min_cov</code>: minimum junction coverage based on short read STAR junction output file. NA if no short read given.</li> <li><code>min_cov_pos</code>: the junction that had the fewest coverage. NA if no short read data given.</li> <li><code>sd_cov</code>: standard deviation of junction coverage counts from short read data. NA if no short read data given.</li> <li><code>FL</code> or <code>FL.&lt;sample&gt;</code>: FL count associated with this isoform per sample if <code>--fl_count</code> is provided, otherwise NA.</li> <li><code>n_indels</code>: total number of indels based on alignment.</li> <li><code>n_indels_junc</code>: number of junctions in this isoform that have alignment indels near the junction site (indicating potentially unreliable junctions).</li> <li><code>bite</code>: TRUE if contains at least one \"bite\" positive SJ.</li> <li><code>iso_exp</code>: short read expression for this isoform if <code>--expression</code> is provided, otherwise NA.</li> <li><code>gene_exp</code>: short read expression for the gene associated with this isoform (summing over all isoforms) if <code>--expression</code> is provided, otherwise NA.</li> <li><code>ratio_exp</code>: ratio of <code>iso_exp</code> to <code>gene_exp</code> if <code>--expression</code> is provided, otherwise NA.</li> <li><code>FSM_class</code>: This feature classifies the transcript according to the expression of other isoforms in the gene to which the transcript belongs. Transcripts belonging to genes that only express one isoform are classified as A. Transcripts belonging to genes that express more than one isoform but none is a FSM are classified as B. Transcripts belonging to genes which express more than one isoform and other isoforms and at least one is a FSM are classified as C.</li> <li><code>coding</code>: Coding potential capacity according to GeneMarkS-T. It can take values of \"coding\" or \"non_coding\"</li> <li><code>ORF_length</code>: predicted ORF length.</li> <li><code>CDS_length</code>: predicted CDS length. It does include the stop codon. </li> <li><code>CDS_start</code>: CDS start.</li> <li><code>CDS_end</code>: CDS end.</li> <li><code>CDS_genomic_start</code>: genomic coordinate of the CDS start. If on - strand, this coord will be greater than the end.</li> <li><code>CDS_genomic_end</code>: genomic coordinate of the CDS end. If on - strand, this coord will be smaller than the start.</li> <li><code>predicted_NMD</code>: TRUE if there's a predicted ORF and CDS ends at least 50bp before the last junction; FALSE if otherwise. NA if non-coding.</li> <li><code>perc_A_downstreamTTS</code>: percent of genomic \"A\"s in the downstream 20 bp window. If this number if high (say &gt; 0.8), the 3' end site of this isoform is probably not reliable.</li> <li><code>seq_A_downstream_TTS</code>: sequence of the downstream 20 bp window.</li> <li><code>dist_to_CAGE_peak</code>: distance to closest TSS based on CAGE Peak data. Negative means the middle of the cage peak is upstream of the isoform TSS and positive means downstream of the isoform TSS. Strand-specific. SQANTI3 only searches for nearby CAGE Peaks within 10000 bp of the PacBio transcript start site. Will be <code>NA</code> if none are found within 10000 bp.</li> <li><code>within_CAGE_peak</code>: TRUE if the transcript start site is within a CAGE Peak. </li> <li><code>dist_to_polyA_site</code>: distance to the closest polyA site, based on polyA site data (e.g. Quant-seq).</li> <li><code>within_polyA_site</code>: TRUE if the transcript start site is within a polyA site, retrieved from polyA site data (e.g. Quant-seq).</li> <li><code>polyA_motif</code>: if <code>--polyA_motif_list</code> is given, shows the top ranking polyA motif found within 50 bp upstream of end.</li> <li><code>polyA_dist</code>: if <code>--polyA_motif_list</code> is given, shows the location of the  last base of the hexamer. Position 0 is the putative poly(A) site. This distance is hence always negative because it is upstream. </li> <li><code>polyA_motif_found</code>: TRUE if a polyA motif given via <code>--polyA_motif_list</code> is detected in the 3'end of the transcript.  </li> <li><code>ORF_seq</code>: Predicted ORF sequence. These sequences are also stored in the <code>*_corrected.faa</code> file.</li> <li><code>ratio_TSS</code>: Using Short-Read data, we measure the mean coverage of the 100bp upstream and downstream a reported TSS. Then we calculate the ratio coverage inside isoform + 0.01/ coverage outside isoform + 0.01. If several SR samples are provided, <code>ratio_TSS</code> will represent the maximum value of the ratios across the samples. This means that if an isoform have a <code>ratio_TSS</code> greater than 1 it is more likely that its TSS is true. Meanwhile, if the <code>ratio_TSS</code> is close or lower than 1, the SR coverage is similar inside and outside the isoform, something that we wouldn't expect if the TSS was true.</li> </ol> <p></p>"},{"location":"Understanding-the-output-of-SQANTI3-QC/#glossary-of-junctions-file-columns-junctionstxt","title":"Glossary of junctions file columns (<code>junctions.txt</code>)","text":"<p>The <code>_junctions.txt</code> file contains the following columns:</p> <ol> <li><code>isoform</code>: Isoform ID.</li> <li><code>junction_number</code>: The i-th junction of the isoform.</li> <li><code>chrom</code>: Chromosome.</li> <li><code>strand</code>: Strand.</li> <li><code>genomic_start_coord</code>: Start of the junction (1-based), note that if on - strand, this would be the junction acceptor site instead.</li> <li><code>genomic_end_coord</code>: End of the junction (1-based), note that if on - strand, this would be the junction donor site instead.</li> <li><code>transcript_coord</code>: Currently not implemented. Ignore.</li> <li><code>junction_category</code>: <code>known</code> if the (donor-acceptor) combination is annotated in the GTF file, <code>novel</code> otherwise. Note that it is possible to have a <code>novel</code> junction even though both the donor and acceptor site are known, since the combination might be novel.</li> <li><code>start_site_category</code>: <code>known</code> if the junction start site is annotated. If on - strand, this is actually the donor site.</li> <li><code>end_site_category</code>: <code>known</code> if the junction end site is annotated. If on - strand, this is actually the acceptor site.</li> <li><code>diff_to_Ref_start_site</code>: distance to closest annotated junction start site. If on - strand, this is actually the donor site.</li> <li><code>diff_to_Ref_end_site</code>: distance to closest annotated junction end site. If on - strand, this is actually the acceptor site.</li> <li><code>bite_junction</code>: Applies only to novel splice junctions. If the novel intron partially overlaps annotated exons the bite value is TRUE, otherwise it is FALSE.</li> <li><code>splice_site</code>: Splice motif.</li> <li><code>RTS_junction</code>: TRUE if junction is predicted to a template switching artifact.</li> <li><code>indel_near_junct</code>: TRUE if there is alignment indel error near the junction site, indicating potential junction incorrectness.</li> <li><code>sample_with_cov</code>: If <code>--coverage</code> (short read junction coverage info) is provided, shows the number of samples (cov files) that have uniquely mapped short read that support this junction.</li> <li><code>total_coverage_unique/multi</code>: Total number of uniquely or multi-mapped short read support from all samples that cover this junction.</li> </ol>"},{"location":"Version-history/","title":"Introduction","text":"<p>This page contains a detailed time-aware (DD/MM/YYYY) account of SQANTI3 releases (&gt;5.0) and the new features and changes introduced in each of them.</p> <p>Please be aware that v5.0 represented a major release of the SQANTI3 software. Versions of SQANTI3 &gt;= 5.0 do not have backward compatibility with previous releases and their output (v4.3 and earlier). Users that wish to apply any of the new functionalities in v5.0 to output files from older versions will herefore need to re-run SQANTI3 QC.</p> <p>See the dedicated site for installation instructions.</p> <p>| See all SQANTI3 releases</p>"},{"location":"Version-history/#sqanti3-v52-latest-04102023","title":"SQANTI3 v5.2 [LATEST, 04/10/2023]","text":""},{"location":"Version-history/#major-changes","title":"Major changes:","text":"<p>QC - Added read coverage threshold (&gt;3 reads) for TSS ratio computation. - Added <code>--ratio_TSS_metric</code> argument for metric selection for TSS ratio computation.</p> <p>ML filter - Expanded report with performance metrics: resulting probability distribution, confusion matrix, test set statistics. - Minimum number of TP/TN isoforms to run ML filter is now 250. - Implemented automatic exclusion of dist_ cols when RM are TP - 'ML' arg to select ML filter mode is now lowercase*, i.e. 'ml'.</p> <p>Rescue - Added <code>--mode</code> argument to rescue to allow selection of <code>automatic</code> or <code>full</code>, modes (default: <code>automatic</code>)</p>"},{"location":"Version-history/#minor-fixesenhancements","title":"Minor fixes/enhancements:","text":"<ul> <li>Added output directory creation and prefix checks in Rescue.</li> <li>Updated filter report syntax to match ggplot2 and tidyverse updates (ggplot&gt;=3.4.0 now required for report).</li> <li>Update requirements to R&gt;=4.3.0.</li> <li>RColorConesa now installed via CRAN.</li> <li>SQ3 version now correctly reported by all scripts.</li> <li>Fixed bugs in filter during QC output file reading (fasta, etc.).</li> <li>Minor bugs/typos.</li> </ul> <p>Download release</p>"},{"location":"Version-history/#patch-to-sqanti3-v512-20072023","title":"Patch to SQANTI3 v5.1.2 (20/07/2023)","text":"<p>Changes: * Speed improvements in rescue when finding best match IDs for rescue candidates. * Output all reference transcripts associated to FSM/ISM found during QC if the <code>--isoform_hits</code> flag is supplied. * Fixed bug in ML filter leading to errors when input data had no mono-exonic transcripts. * Fixed saturation curve bug in pigeon report. * Fixes conda environment installation of bcbio-gff.</p> <p>Download release</p>"},{"location":"Version-history/#patch-to-sqanti3-v511-19012023","title":"Patch to SQANTI3 v5.1.1 (19/01/2023)","text":"<p>Changes: * Adapt for pigeon compatibility. * Bug fixes in STM function. * Minor fixes in ML filter documentation and output file handling. * Fixed bug leading to incorrect classification of genic intron transcripts.</p> <p>Download release</p>"},{"location":"Version-history/#sqanti3-v51-22072022","title":"SQANTI3 v5.1 (22/07/2022)","text":""},{"location":"Version-history/#major-changes_1","title":"Major changes:","text":"<ul> <li>Implemented new rescue strategy to recover transcriptome diversity lost after filtering (see details at the SQ rescue wiki).</li> <li>Updated conda environment to include rescue dependencies. We recommend creating the environment again in order for SQANTI3 to run without error.</li> <li>Fixed behavior of mono-exon transcripts during ML filter:</li> <li>FSM now undergo intra-primming evaluation if they are mono-exons.</li> <li>Corrected ML filter output when <code>--force_multi_exon</code> option is supplied: mono-exon transcripts will now be labeled as Artifacts.</li> <li>Fixed reasons file output by rules filter: the table now includes correct filtering reasons for mono-exon transcripts.</li> <li>Added an option to rules filter to control for mono-exon transcripts (previously available in ML filter).</li> <li>Modified the output of SQANTI3 QC to incorporate the creation of a complete <code>params.txt</code> file, i.e. including all arguments and the full paths of all supplied files.</li> </ul> <p>#### Minor fixes/enhancements:    - Fixed output path for IsoAnnotLite GFF3 that prevented writing the file to the correct output directory when -gff3 option was not used.    - Set temporary file dir for HTML report creation (fixes Singularity container error).</p> <p>Download release</p>"},{"location":"Version-history/#sqanti3-v50-01062022","title":"SQANTI3 v5.0 (01/06/2022)","text":""},{"location":"Version-history/#major-changes_2","title":"Major changes:","text":"<ul> <li>Implemented new machine learning-based filter.</li> <li>Updated rules filter: users can now define their own set of rules using a JSON file. By default, the rules filter applies the same set of rules that were implemented in the old <code>sqanti3_RulesFilter.py</code> script.</li> <li>The <code>sqanti3_RulesFilter.py</code> script is now deprecated and has been replaced by <code>sqanti3_filter.py</code>, which works a wrapper for both filters (see details in the documentation).</li> <li>IsoAnnotLite updated to version 2.7.3.</li> <li>Substantial modification of the SQANTI3 directory structure, with <code>utilities</code> folder now being divided into subfolders that group the scripts by their function.</li> <li>Added a column in the classification file to indicate whether a polyA motif was found, which adds to the existing column detailing the detected motif (details here).</li> <li>Changed CAGE argument and CAGE/polyA columns to capital letters (for consistency across columns and arguments).</li> <li>The <code>example</code> folder now includes sample commands and output files for SQANTI3 QC, rules filter and machine learning filter.</li> <li>Added new supported transcript model (STM) plots to the SQANTI3 QC report.</li> </ul>"},{"location":"Version-history/#minor-fixesenhancements_1","title":"Minor fixes/enhancements:","text":"<ul> <li>Included cython (cDNA_cupcake dependency) as a dependency in the SQANTI3 conda environment.</li> <li>pip installed in conda environment.</li> <li>When supplied, the new <code>sqanti3_filter.py</code> filters the <code>sqanti3_qc.py</code> output files using the filter result (rules or ML). This was not previously done by <code>sqanti3_RulesFilter.py</code>.</li> <li>Antisense vs intergenic bug: fixed inconsistencies in classification of isoforms across the two categories.</li> <li>Fixed deprecation warnings in calculation of ratioTSS.</li> <li>Minor report updates.</li> </ul> <p>Download release</p>"},{"location":"_Sidebar/","title":"Sidebar","text":"<p>Wiki index * Introduction to SQANTI3 * Dependencies and installation * Version history * Isoform classification: categories and subcategories * Running SQANTI3 from the wrapper * Running SQANTI3 quality control * Understanding the output of SQANTI3 QC * IsoAnnotLite * Running SQANTI3 filter * Running SQANTI3 rescue * Tutorial: running SQANTI3 on an example dataset * Running SQANTI-reads * Memory requirements to use parallelization</p>"}]}